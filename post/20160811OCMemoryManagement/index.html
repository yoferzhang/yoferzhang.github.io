
 <!DOCTYPE HTML>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  
    <title>【iOS】Advanced Memory Management Programming Guide 高级内存管理编程指南(官方文档翻译) | YoferZhang 的博客</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="Yofer Zhang">
    

    
    <meta name="description" content="Advanced Memory Management Programming Guide - 高级内存管理编程指南(官方文档翻译)

版权声明：本文为博主原创翻译，如需转载请注明出处。
新博客文章地址：Advanced Memory Management Programming Guide 高级内存管理编程指南(官方文档翻译)CSDN文章地址：Advanced Memory Management">
<meta property="og:type" content="article">
<meta property="og:title" content="【iOS】Advanced Memory Management Programming Guide 高级内存管理编程指南(官方文档翻译)">
<meta property="og:url" content="http://yoferzhang.com/post/20160811OCMemoryManagement/index.html">
<meta property="og:site_name" content="YoferZhang 的博客">
<meta property="og:description" content="Advanced Memory Management Programming Guide - 高级内存管理编程指南(官方文档翻译)

版权声明：本文为博主原创翻译，如需转载请注明出处。
新博客文章地址：Advanced Memory Management Programming Guide 高级内存管理编程指南(官方文档翻译)CSDN文章地址：Advanced Memory Management">
<meta property="og:image" content="http://ww4.sinaimg.cn/large/a9c4d5f6gw1f6pt6mxxf6j212p0mugpd.jpg">
<meta property="og:image" content="http://ww3.sinaimg.cn/large/a9c4d5f6gw1f6q04aqj54j20ek0mk0v2.jpg">
<meta property="og:updated_time" content="2018-06-06T02:34:11.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="【iOS】Advanced Memory Management Programming Guide 高级内存管理编程指南(官方文档翻译)">
<meta name="twitter:description" content="Advanced Memory Management Programming Guide - 高级内存管理编程指南(官方文档翻译)

版权声明：本文为博主原创翻译，如需转载请注明出处。
新博客文章地址：Advanced Memory Management Programming Guide 高级内存管理编程指南(官方文档翻译)CSDN文章地址：Advanced Memory Management">
<meta name="twitter:image" content="http://ww4.sinaimg.cn/large/a9c4d5f6gw1f6pt6mxxf6j212p0mugpd.jpg">
<meta name="twitter:creator" content="@LuciferZhangyq">
<link rel="publisher" href="110295955443575724222">

    
    <link rel="alternative" href="/atom.xml" title="YoferZhang 的博客" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/faviconr.ico">
    
    
    <link rel="apple-touch-icon" href="/img/jacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/jacman.jpg">
    
    <link rel="stylesheet" href="/css/style.css">
</head>

  <body>
    <header>
      
<div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/logo.jpg" alt="YoferZhang 的博客" title="YoferZhang 的博客"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="YoferZhang 的博客">YoferZhang 的博客</a></h1>
				<h2 class="blog-motto">数学出身，功底扎实，热爱编程，虽然编程起步晚，但是冲劲十足。</h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="菜单">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/index/">索引 | Index</a></li>
					
						<li><a href="/archives">归档 | Archives</a></li>
					
						<li><a href="/about">关于 | About</a></li>
					
					<li>
 					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="search" id="search" name="q" autocomplete="off" maxlength="20" placeholder="搜索" />
						<input type="hidden" name="q" value="site:yoferzhang.com">
					</form>
					
					</li>
				</ul>
			</nav>			
</div>
    </header>
    <div id="container">
      <div id="main" class="post" itemscope itemprop="blogPost">
  
	<article itemprop="articleBody"> 
		<header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/post/20160811OCMemoryManagement/" title="【iOS】Advanced Memory Management Programming Guide 高级内存管理编程指南(官方文档翻译)" itemprop="url">【iOS】Advanced Memory Management Programming Guide 高级内存管理编程指南(官方文档翻译)</a>
  </h1>
  <p class="article-author">By
       
		<a href="https://plus.google.com/110295955443575724222?rel=author" title="Yofer Zhang" target="_blank" itemprop="author">Yofer Zhang</a>
		
  <p class="article-time">
    <time datetime="2016-08-11T06:27:38.000Z" itemprop="datePublished"> 发表于 2016-08-11</time>
    
  </p>
</header>
	<div class="article-content">
		
		<div id="toc" class="toc-article">
			<strong class="toc-title">文章目录</strong>
		
			<ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#About-Memory-Management-关于内存管理"><span class="toc-number">1.</span> <span class="toc-text">About Memory Management - 关于内存管理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#At-a-Glance-简单了解"><span class="toc-number">1.1.</span> <span class="toc-text">At a Glance - 简单了解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Good-Practices-Prevent-Memory-Related-Problems-好的做法，防止内存相关的问题"><span class="toc-number">1.1.1.</span> <span class="toc-text">Good Practices Prevent Memory-Related Problems - 好的做法，防止内存相关的问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Use-Analysis-Tools-to-Debug-Memory-Problems-使用分析工具来调试内存问题"><span class="toc-number">1.1.2.</span> <span class="toc-text">Use Analysis Tools to Debug Memory Problems - 使用分析工具来调试内存问题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Memory-Management-Policy-内存管理策略"><span class="toc-number">2.</span> <span class="toc-text">Memory Management Policy - 内存管理策略</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Basic-Memory-Management-Rules-基本内存管理规则"><span class="toc-number">2.1.</span> <span class="toc-text">Basic Memory Management Rules - 基本内存管理规则</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#A-Simple-Example-一个简单的例子"><span class="toc-number">2.1.1.</span> <span class="toc-text">A Simple Example - 一个简单的例子</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Use-autorelease-to-Send-a-Deferred-release-使用autorelease发送延迟release"><span class="toc-number">2.1.2.</span> <span class="toc-text">Use autorelease to Send a Deferred release - 使用autorelease发送延迟release</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#You-Don’t-Own-Objects-Returned-by-Reference-你没有通过引用返回的对象的所有权"><span class="toc-number">2.1.3.</span> <span class="toc-text">You Don’t Own Objects Returned by Reference - 你没有通过引用返回的对象的所有权</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Implement-dealloc-to-Relinquish-Ownership-of-Objects-实现dealloc放弃对象的所有权"><span class="toc-number">2.2.</span> <span class="toc-text">Implement dealloc to Relinquish Ownership of Objects - 实现dealloc放弃对象的所有权</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Core-Foundation-Uses-Similar-but-Different-Rules-Core-Foundation使用了类似但不同的规则"><span class="toc-number">2.3.</span> <span class="toc-text">Core Foundation Uses Similar but Different Rules - Core Foundation使用了类似但不同的规则</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#内存管理实践"><span class="toc-number">3.</span> <span class="toc-text">内存管理实践</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Use-Accessor-Methods-to-Make-Memory-Management-Easier-使用访问器方法使内存管理更容易"><span class="toc-number">3.1.</span> <span class="toc-text">Use Accessor Methods to Make Memory Management Easier - 使用访问器方法使内存管理更容易</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Use-Accessor-Methods-to-Set-Property-Values-使用访问器方法来设置属性值"><span class="toc-number">3.1.1.</span> <span class="toc-text">Use Accessor Methods to Set Property Values - 使用访问器方法来设置属性值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Don’t-Use-Accessor-Methods-in-Initializer-Methods-and-dealloc-不要在初始化方法和-dealloc中使用访问器方法"><span class="toc-number">3.1.2.</span> <span class="toc-text">Don’t Use Accessor Methods in Initializer Methods and dealloc - 不要在初始化方法和 dealloc中使用访问器方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Use-Weak-References-to-Avoid-Retain-Cycles-使用弱引用来避免所有权的死锁"><span class="toc-number">3.2.</span> <span class="toc-text">Use Weak References to Avoid Retain Cycles - 使用弱引用来避免所有权的死锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Avoid-Causing-Deallocation-of-Objects-You’re-Using-避免你正在使用的对象被-dealloc"><span class="toc-number">3.3.</span> <span class="toc-text">Avoid Causing Deallocation of Objects You’re Using - 避免你正在使用的对象被 dealloc</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Don’t-Use-dealloc-to-Manage-Scarce-Resources-不要使用-dealloc-来管理关键系统资源"><span class="toc-number">3.4.</span> <span class="toc-text">Don’t Use dealloc to Manage Scarce Resources - 不要使用 dealloc 来管理关键系统资源</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Collections-Own-the-Objects-They-Contain-Collections-拥有他们所包含的对象"><span class="toc-number">3.5.</span> <span class="toc-text">Collections Own the Objects They Contain - Collections 拥有他们所包含的对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Ownership-Policy-Is-Implemented-Using-Retain-Counts-通过引用计数实现所有权策略"><span class="toc-number">3.6.</span> <span class="toc-text">Ownership Policy Is Implemented Using Retain Counts - 通过引用计数实现所有权策略</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Using-Autorelease-Pool-Blocks-使用自动释放池块"><span class="toc-number">4.</span> <span class="toc-text">Using Autorelease Pool Blocks - 使用自动释放池块</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#About-Autorelease-Pool-Blocks-关于自动释放池块"><span class="toc-number">4.1.</span> <span class="toc-text">About Autorelease Pool Blocks - 关于自动释放池块</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Use-Local-Autorelease-Pool-Blocks-to-Reduce-Peak-Memory-Footprint-使用本地自动释放池块，降低峰值内存占用"><span class="toc-number">4.2.</span> <span class="toc-text">Use Local Autorelease Pool Blocks to Reduce Peak Memory Footprint - 使用本地自动释放池块，降低峰值内存占用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Autorelease-Pool-Blocks-and-Threads-自动释放池块和线程"><span class="toc-number">4.3.</span> <span class="toc-text">Autorelease Pool Blocks and Threads - 自动释放池块和线程</span></a></li></ol></li></ol>
		
		</div>
		
		<p>Advanced Memory Management Programming Guide - 高级内存管理编程指南(官方文档翻译)</p>
<blockquote>
<p>版权声明：本文为博主原创翻译，如需转载请注明出处。</p>
<p>新博客文章地址：<a href="http://yoferzhang.com/post/20160811OCMemoryManagement/">Advanced Memory Management Programming Guide 高级内存管理编程指南(官方文档翻译)</a><br>CSDN文章地址：<a href="http://blog.csdn.net/zyq522376829/article/details/52191501" target="_blank" rel="external">Advanced Memory Management Programming Guide 高级内存管理编程指南(官方文档翻译)</a></p>
<p>苹果源文档地址 - <a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/MemoryMgmt/Articles/MemoryMgmt.html#//apple_ref/doc/uid/10000011-SW1" target="_blank" rel="external">点击这里</a></p>
</blockquote>
<h1 id="About-Memory-Management-关于内存管理"><a href="#About-Memory-Management-关于内存管理" class="headerlink" title="About Memory Management - 关于内存管理"></a>About Memory Management - 关于内存管理</h1><p>Application memory management is the process of allocating memory during your program’s runtime, using it, and freeing it when you are done with it. A well-written program uses as little memory as possible. In Objective-C, it can also be seen as a way of distributing ownership of limited memory resources among many pieces of data and code. When you have finished working through this guide, you will have the knowledge you need to manage your application’s memory by explicitly managing the life cycle of objects and freeing them when they are no longer needed.</p>
<p>应用程序的内存管理是程序运行时内存分配的过程，使用它，并当你用完它的时候释放它。写得好的程序应该尽可能少的使用内存。在Objective-C，它也可以被看作是分布 数据和代码的许多块当中的有限的内存资源的所有权的方法。当您完成通过这一指南的工作，你将有一些关于你的应用程序的内存管理知识，你需要明确管理对象的生命周期，并且当他们不再需要管理时释放他们。</p>
<a id="more"></a>
<p>Although memory management is typically considered at the level of an individual object, your goal is actually to manage object graphs. You want to make sure that you have no more objects in memory than you actually need.</p>
<p>虽然内存管理通常被认为是在单独对象的水平，你的目标其实是管理 <a href="https://developer.apple.com/library/ios/documentation/General/Conceptual/DevPedia-CocoaCore/ObjectGraph.html#//apple_ref/doc/uid/TP40008195-CH54" target="_blank" rel="external">object graphs</a>，你要确保你在内存中没有比实际需要 更多的对象。</p>
<center><br>    <img src="http://ww4.sinaimg.cn/large/a9c4d5f6gw1f6pt6mxxf6j212p0mugpd.jpg" alt=""><br></center>

<h2 id="At-a-Glance-简单了解"><a href="#At-a-Glance-简单了解" class="headerlink" title="At a Glance - 简单了解"></a>At a Glance - 简单了解</h2><p>Objective-C provides two methods of application memory management.</p>
<ul>
<li>In the method described in this guide, referred to as “manual retain-release” or MRR, you explicitly manage memory by keeping track of objects you own. This is implemented using a model, known as reference counting, that the Foundation class NSObject provides in conjunction with the runtime environment.</li>
<li>In Automatic Reference Counting, or ARC, the system uses the same reference counting system as MRR, but it inserts the appropriate memory management method calls for you at compile-time. You are strongly encouraged to use ARC for new projects. If you use ARC, there is typically no need to understand the underlying implementation described in this document, although it may in some situations be helpful. For more about ARC, see Transitioning to ARC Release Notes.</li>
</ul>
<p>Objective-C的应用程序提供了内存管理的两种方法。</p>
<ol>
<li>在本指南中说明的方法，通过跟踪你自己的对象，明确地管理内存，被称为“手动保留释放(manual retain-release)”或MRR。这是用一个模型来实现，称为引用计数，是基础类 <a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSObject_Class/index.html#//apple_ref/occ/cl/NSObject" target="_blank" rel="external">NSObject</a> 提供的，并与运行环境相结合。</li>
<li>在自动引用计数，或ARC，该系统使用相同的引用计数系统MRR，但它在编译的时候要求你插入适当的内存管理方法。强烈建议您为新项目使用ARC。如果使用ARC，通常没有必要理解本文档中描述的底层实现，虽然它可能在某些情况下是有益的。欲了解更多有关ARC，请参阅 <a href="https://developer.apple.com/library/ios/releasenotes/ObjectiveC/RN-TransitioningToARC/Introduction/Introduction.html#//apple_ref/doc/uid/TP40011226" target="_blank" rel="external">Transitioning to ARC Release Notes</a>。</li>
</ol>
<h3 id="Good-Practices-Prevent-Memory-Related-Problems-好的做法，防止内存相关的问题"><a href="#Good-Practices-Prevent-Memory-Related-Problems-好的做法，防止内存相关的问题" class="headerlink" title="Good Practices Prevent Memory-Related Problems - 好的做法，防止内存相关的问题"></a>Good Practices Prevent Memory-Related Problems - 好的做法，防止内存相关的问题</h3><p>There are two main kinds of problem that result from incorrect memory management:</p>
<ul>
<li>Freeing or overwriting data that is still in use</li>
</ul>
<p>This causes memory corruption, and typically results in your application crashing, or worse, corrupted user data.</p>
<ul>
<li>Not freeing data that is no longer in use causes memory leaks</li>
</ul>
<p>A memory leak is where allocated memory is not freed, even though it is never used again. Leaks cause your application to use ever-increasing amounts of memory, which in turn may result in poor system performance or your application being terminated.</p>
<p>有两种主要类型的问题，即不正确的内存管理导致：</p>
<ul>
<li>释放或改写仍在使用的数据</li>
</ul>
<p>这会导致内存损坏，通常会导致应用程序崩溃，或者更糟，破坏用户数据。</p>
<ul>
<li>不释放不再使用的数据导致内存泄漏</li>
</ul>
<p>内存泄漏就是分配的内存不释放，即使它永远不会再次使用。泄漏导致您的应用程序使用的内存量的不断增加，这反过来又可能导致较差的系统性能或您的应用程序被终止。</p>
<p>Thinking about memory management from the perspective of reference counting, however, is frequently counterproductive, because you tend to consider memory management in terms of the implementation details rather than in terms of your actual goals. Instead, you should think of memory management from the perspective of object ownership and object graphs.</p>
<p>然而，从引用计数的角度思考内存管理，经常是适得其反，因为你往往会考虑内存管理的实施细则方面，而不是在你的实际目标方面。相反，你应该从对象所有权和 <a href="https://developer.apple.com/library/ios/documentation/General/Conceptual/DevPedia-CocoaCore/ObjectGraph.html#//apple_ref/doc/uid/TP40008195-CH54" target="_blank" rel="external">object graphs</a> 的角度去思考内存管理。</p>
<p>Cocoa uses a straightforward naming convention to indicate when you own an object returned by a method.</p>
<p>当你拥有被一个方法返回的对象，<code>Cocoa</code> 使用一个简单的命名约定来指明。</p>
<p>See Memory Management Policy.</p>
<p>参阅 <a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/MemoryMgmt/Articles/mmRules.html#//apple_ref/doc/uid/20000994-BAJHFBGH" target="_blank" rel="external">Memory Management Policy</a></p>
<p>Although the basic policy is straightforward, there are some practical steps you can take to make managing memory easier, and to help to ensure your program remains reliable and robust while at the same time minimizing its resource requirements.</p>
<p>虽然基本ce’lue是直接的，也有一些实际的步骤，你可以使内存管理更容易，并帮助确保您的程序是可靠的和有鲁棒性的同时减少资源需求。</p>
<p>See Practical Memory Management.</p>
<p>参阅 <a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/MemoryMgmt/Articles/mmPractical.html#//apple_ref/doc/uid/TP40004447-SW1" target="_blank" rel="external">Practical Memory Management</a></p>
<p>Autorelease pool blocks provide a mechanism whereby you can send an object a “deferred” release message. This is useful in situations where you want to relinquish ownership of an object, but want to avoid the possibility of it being deallocated immediately (such as when you return an object from a method). There are occasions when you might use your own autorelease pool blocks.</p>
<p>自动释放池模块提供了一个机制，使您可以发送对象的“延迟” <code>release</code> 消息。你想放弃一个对象的所有权，但要避免它立刻释放（如你从一个方法返回一个对象时），这是很有用的。有些时候你可能会使用自己的自动释放池</p>
<p>See Using Autorelease Pool Blocks.</p>
<p>参阅 <a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/MemoryMgmt/Articles/mmAutoreleasePools.html#//apple_ref/doc/uid/20000047-CJBFBEDI" target="_blank" rel="external">Using Autorelease Pool Blocks</a></p>
<h3 id="Use-Analysis-Tools-to-Debug-Memory-Problems-使用分析工具来调试内存问题"><a href="#Use-Analysis-Tools-to-Debug-Memory-Problems-使用分析工具来调试内存问题" class="headerlink" title="Use Analysis Tools to Debug Memory Problems - 使用分析工具来调试内存问题"></a>Use Analysis Tools to Debug Memory Problems - 使用分析工具来调试内存问题</h3><p>To identify problems with your code at compile time, you can use the Clang Static Analyzer that is built into Xcode.</p>
<p>If memory management problems do nevertheless arise, there are other tools and techniques you can use to identify and diagnose the issues.</p>
<ul>
<li>Many of the tools and techniques are described in Technical Note TN2239, iOS Debugging Magic, in particular the use of NSZombie to help find over-released object.</li>
<li>You can use Instruments to track reference counting events and look for memory leaks. See Collecting Data on Your App.</li>
</ul>
<p>为了确定你的代码在编译时出现问题，则可以使用 <a href="https://developer.apple.com/library/ios/recipes/xcode_help-source_editor/chapters/Analyze.html#//apple_ref/doc/uid/TP40009975-CH4" target="_blank" rel="external">Clang Static Analyzer</a> ，内置在Xcode中。</p>
<p>如果你仍然出现内存管理问题，还有其他的工具和技术可以用来识别和诊断问题。</p>
<ul>
<li>许多工具和技术的技术说明在 <code>Technical Note TN2239</code> 中有描述，<a href="https://developer.apple.com/library/ios/technotes/tn2239/_index.html#//apple_ref/doc/uid/DTS40010638" target="_blank" rel="external">iOS Debugging Magic</a> ，特别是使用的 <code>NSZombie</code> ，以帮助找到还未释放的对象。</li>
<li>您可以使用仪器来跟踪引用计数的事件，并查找内存泄漏。请参阅 <a href="https://developer.apple.com/library/ios/documentation/DeveloperTools/Conceptual/InstrumentsUserGuide/TheInstrumentsWorkflow.html#//apple_ref/doc/uid/TP40004652-CH5" target="_blank" rel="external">Collecting Data on Your App</a></li>
</ul>
<h1 id="Memory-Management-Policy-内存管理策略"><a href="#Memory-Management-Policy-内存管理策略" class="headerlink" title="Memory Management Policy - 内存管理策略"></a>Memory Management Policy - 内存管理策略</h1><p>The basic model used for memory management in a reference-counted environment is provided by a combination of methods defined in the NSObject  protocol and a standard method naming convention. The NSObject class also defines a method, dealloc, that is invoked automatically when an object is deallocated. This article describes all the basic rules you need to know to manage memory correctly in a Cocoa program, and provides some examples of correct usage.</p>
<p>在一个引用计数环境用于内存管理的基本模型 是由 在 <a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Protocols/NSObject_Protocol/index.html#//apple_ref/occ/intf/NSObject" target="_blank" rel="external">NSObject</a> 协议和标准方法命名约定中所定义的方法的组合提供的。该NSObject类也定义了一种方法，dealloc，当一个对象被释放时自动调用。本文介绍了所有你需要知道的 <code>Cocoa</code> 程序正确处理内存中的基本规则，并提供了一些正确的用法的例子。</p>
<h2 id="Basic-Memory-Management-Rules-基本内存管理规则"><a href="#Basic-Memory-Management-Rules-基本内存管理规则" class="headerlink" title="Basic Memory Management Rules - 基本内存管理规则"></a>Basic Memory Management Rules - 基本内存管理规则</h2><p>The memory management model is based on object ownership. Any object may have one or more owners. As long as an object has at least one owner, it continues to exist. If an object has no owners, the runtime system destroys it automatically. To make sure it is clear when you own an object and when you do not, Cocoa sets the following policy:</p>
<ul>
<li>You own any object you create</li>
</ul>
<p>You create an object using a method whose name begins with “alloc”, “new”, “copy”, or “mutableCopy” (for example, alloc, newObject, or mutableCopy).</p>
<ul>
<li>You can take ownership of an object using retain</li>
</ul>
<p>A received object is normally guaranteed to remain valid within the method it was received in, and that method may also safely return the object to its invoker. You use retain in two situations: (1) In the implementation of an accessor method or an init method, to take ownership of an object you want to store as a property value; and (2) To prevent an object from being invalidated as a side-effect of some other operation (as explained in Avoid Causing Deallocation of Objects You’re Using).</p>
<ul>
<li>When you no longer need it, you must relinquish ownership of an object you own</li>
</ul>
<p>You relinquish ownership of an object by sending it a release message or an autorelease message. In Cocoa terminology, relinquishing ownership of an object is therefore typically referred to as “releasing” an object.</p>
<ul>
<li>You must not relinquish ownership of an object you do not own</li>
</ul>
<p>This is just corollary of the previous policy rules, stated explicitly.</p>
<p>内存管理模型是基于对象的所有权。任何对象可具有一个或多个所有者。只要对象具有至少一个所有者，它继续存在。 如果一个对象没有所有者，运行时系统会自动将它摧毁。为了确保清晰的知道当你拥有一个对象或者没有拥有，<code>Cocoa</code>提出以下策略：</p>
<ul>
<li>你拥有你所创建的任何对象</li>
</ul>
<p>使用 “alloc”, “new”, “copy”, or “mutableCopy”（例如，<a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSObject_Class/index.html#//apple_ref/occ/clm/NSObject/alloc" target="_blank" rel="external">alloc</a> ， <code>newObject</code> 或 <a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSObject_Class/index.html#//apple_ref/occ/instm/NSObject/mutableCopy" target="_blank" rel="external">mutableCopy</a> ）这种类型开头的方法来创建一个对象。</p>
<ul>
<li>可以使用 <code>retain</code> 保留对象的所有权</li>
</ul>
<p>接收到的对象通常是保证其接收的方法中仍然有效，而且方法也可以安全地将对象返回到它的调用。在两种情况下您可以使用 <code>retain</code> ，(1)在存取方法或 <code>init</code>方法的实现中，你希望将得到的返回对象作为成员变量(property)来存储。(2)在执行某些操作时，为了防止对象被废止。（例如 <a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/MemoryMgmt/Articles/mmPractical.html#//apple_ref/doc/uid/20000043-1000922" target="_blank" rel="external">Avoid Causing Deallocation of Objects You’re Using</a>）</p>
<ul>
<li>当你不再需要它，你必须放弃你自己的对象的所有权</li>
</ul>
<p>您可以通过发送一个 <a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Protocols/NSObject_Protocol/index.html#//apple_ref/occ/intfm/NSObject/release" target="_blank" rel="external">release</a> 消息或 <a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Protocols/NSObject_Protocol/index.html#//apple_ref/occ/intfm/NSObject/autorelease" target="_blank" rel="external">autorelease</a> 消息放弃对象的所有权。在<code>Cocoa</code> 术语中，所谓 放弃所有权,就是 release 一个对象。</p>
<ul>
<li>对于你不拥有的对象，不要尝试放弃所有权</li>
</ul>
<p>这是上面的策略规则的推论，明确表示。</p>
<h3 id="A-Simple-Example-一个简单的例子"><a href="#A-Simple-Example-一个简单的例子" class="headerlink" title="A Simple Example - 一个简单的例子"></a>A Simple Example - 一个简单的例子</h3><p>为了说明这个策略，可以考虑下面的代码片段：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    Person *aPerson = [[Person alloc] init];</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="built_in">NSString</span> *name = aPerson.fullName;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    [aPerson release];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The Person object is created using the alloc method, so it is subsequently sent a release message when it is no longer needed. The person’s name is not retrieved using any of the owning methods, so it is not sent a release message. Notice, though, that the example uses release rather than autorelease.</p>
<p>Person对象是使用alloc方法创建，所以不再需要它时候，接着发送一个 <code>release</code>的消息给它。人的姓名未使用任何拥有方法的检索，因此它不发送一个<code>release</code>消息。请注意，该示例使用<code>release</code> ，而不是<code>autorelease</code> 。</p>
<h3 id="Use-autorelease-to-Send-a-Deferred-release-使用autorelease发送延迟release"><a href="#Use-autorelease-to-Send-a-Deferred-release-使用autorelease发送延迟release" class="headerlink" title="Use autorelease to Send a Deferred release - 使用autorelease发送延迟release"></a>Use autorelease to Send a Deferred release - 使用<code>autorelease</code>发送延迟<code>release</code></h3><p>You use autorelease when you need to send a deferred release message—typically when returning an object from a method. For example, you could implement the fullName method like this:</p>
<p>当你需要发送延迟<code>release</code>消息，可以使用autorelease ，通常当从方法返回一个对象时。例如，你可以实现的<code>fullName</code>这样的方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSString</span> *)fullName &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *string = [[[<span class="built_in">NSString</span> alloc] initWithFormat:<span class="string">@"%@ %@"</span>,</span><br><span class="line">                                          <span class="keyword">self</span>.firstName, <span class="keyword">self</span>.lastName] autorelease];</span><br><span class="line">    <span class="keyword">return</span> string;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>You own the string returned by alloc. To abide by the memory management rules, you must relinquish ownership of the string before you lose the reference to it. If you use release, however, the string will be deallocated before it is returned (and the method would return an invalid object). Using autorelease, you signify that you want to relinquish ownership, but you allow the caller of the method to use the returned string before it is deallocated.</p>
<p>You could also implement the fullName method like this:</p>
<p>你自己通过 <code>alloc</code> 返回一个 <code>string</code>。遵守内存管理规则，你必须在失去引用之前放弃该字符串的所有权。但是如果使用<code>release</code>，字符串将在返回之前被释放（并且该方法将返回一个无效对象）。使用<code>autorelease</code>，你表示要放弃所有权，但允许方法的调用者在它被销毁之前使用返回的字符串。</p>
<p>你也可以像下面这样实现<code>fullName</code>的方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSString</span> *)fullName &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *string = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@ %@"</span>,</span><br><span class="line">                                 <span class="keyword">self</span>.firstName, <span class="keyword">self</span>.lastName];</span><br><span class="line">    <span class="keyword">return</span> string;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Following the basic rules, you don’t own the string returned by stringWithFormat:, so you can safely return the string from the method.</p>
<p>By way of contrast, the following implementation is wrong:</p>
<p>遵循基本规则，通过 <code>stringWithFormat</code>返回的字符串，你并不拥有它，(译者:请注 意到这里并没有使用 alloc,方法名也不是以 init 开始)，这样你就可以放心地从该方法返回字符串。</p>
<p>通过对比的方式，下面的实施是错误的 ：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSString</span> *)fullName &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *string = [[<span class="built_in">NSString</span> alloc] initWithFormat:<span class="string">@"%@ %@"</span>,</span><br><span class="line">                                         <span class="keyword">self</span>.firstName, <span class="keyword">self</span>.lastName];</span><br><span class="line">    <span class="keyword">return</span> string;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>According to the naming convention, there is nothing to denote that the caller of the fullName method owns the returned string. The caller therefore has no reason to release the returned string, and it will thus be leaked.</p>
<p>根据命名规则，没有地方说明 <code>fullName</code> 方法的调用者拥有返回的 <code>string</code>。因此，调用者没有理由释放返回的字符串，它会因此被泄露。</p>
<h3 id="You-Don’t-Own-Objects-Returned-by-Reference-你没有通过引用返回的对象的所有权"><a href="#You-Don’t-Own-Objects-Returned-by-Reference-你没有通过引用返回的对象的所有权" class="headerlink" title="You Don’t Own Objects Returned by Reference - 你没有通过引用返回的对象的所有权"></a>You Don’t Own Objects Returned by Reference - 你没有通过引用返回的对象的所有权</h3><p>Some methods in Cocoa specify that an object is returned by reference (that is, they take an argument of type ClassName <em>* or id </em>). A common pattern is to use an NSError object that contains information about an error if one occurs, as illustrated by initWithContentsOfURL:options:error: (NSData) and initWithContentsOfFile:encoding:error: (NSString).</p>
<p>In these cases, the same rules apply as have already been described. When you invoke any of these methods, you do not create the NSError object, so you do not own it. There is therefore no need to release it, as illustrated in this example:</p>
<p><code>Cocoa</code> 中的一些方法指定一个对象是通过引用返回（即 它们的返回类型是 <code>ClassName **</code> 或者 <code>id *</code>），常见的情况是当出现错误异常时,一个 <code>NSError</code> 对象被用来承载错误的信息。比如 <a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSData_Class/index.html#//apple_ref/occ/instm/NSData/initWithContentsOfURL:options:error:" target="_blank" rel="external">initWithContentsOfURL:options:error:</a> (NSData) 和 <a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSString_Class/index.html#//apple_ref/occ/instm/NSString/initWithContentsOfFile:encoding:error:" target="_blank" rel="external">initWithContentsOfFile:encoding:error:</a> (NSString)。</p>
<p>在这些情况下，同样的规则适用。当你调用任何这些方法，你没有创建 <code>NSError</code> 对象，所以你没有拥有它。 因此，没有必要将它释放，如本例所示：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *fileName = &lt;<span class="meta">#Get a file name#&gt;;</span></span><br><span class="line"><span class="built_in">NSError</span> *error;</span><br><span class="line"><span class="built_in">NSString</span> *string = [[<span class="built_in">NSString</span> alloc] initWithContentsOfFile:fileName</span><br><span class="line">                        encoding:<span class="built_in">NSUTF8StringEncoding</span> error:&amp;error];</span><br><span class="line"><span class="keyword">if</span> (string == <span class="literal">nil</span>) &#123;</span><br><span class="line">    <span class="comment">// Deal with error...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">[string release];</span><br></pre></td></tr></table></figure>
<h2 id="Implement-dealloc-to-Relinquish-Ownership-of-Objects-实现dealloc放弃对象的所有权"><a href="#Implement-dealloc-to-Relinquish-Ownership-of-Objects-实现dealloc放弃对象的所有权" class="headerlink" title="Implement dealloc to Relinquish Ownership of Objects - 实现dealloc放弃对象的所有权"></a>Implement dealloc to Relinquish Ownership of Objects - 实现<code>dealloc</code>放弃对象的所有权</h2><p>The NSObject class defines a method, dealloc, that is invoked automatically when an object has no owners and its memory is reclaimed—in Cocoa terminology it is “freed” or “deallocated.”. The role of the dealloc method is to free the object’s own memory, and to dispose of any resources it holds, including ownership of any object instance variables.</p>
<p>The following example illustrates how you might implement a dealloc method for a Person class:</p>
<p>NSObject类定义的方法，<a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSObject_Class/index.html#//apple_ref/occ/instm/NSObject/dealloc" target="_blank" rel="external">dealloc</a>，这个方法在对象无主(没有所有者)的情况下, 当内存回收的时候会由系统自动调用，<code>Cocoa</code>术语说，就是 <code>freed</code> 或者 <code>deallocated</code>。<code>dealloc</code>方法的作用就是释放对象自身的内存，以及处置已持有的任何资源，包括任何对象的实例变量的所有权。</p>
<p>下面的例子说明了如何实现一个Person类的<code>dealloc</code>方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span> (retain) <span class="built_in">NSString</span> *firstName;</span><br><span class="line"><span class="keyword">@property</span> (retain) <span class="built_in">NSString</span> *lastName;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">readonly</span>) <span class="built_in">NSString</span> *fullName;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span></span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">- (<span class="keyword">void</span>)dealloc</span><br><span class="line">    [_firstName release];</span><br><span class="line">    [_lastName release];</span><br><span class="line">    [<span class="keyword">super</span> dealloc];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>Important: Never invoke another object’s dealloc method directly.<br>You must invoke the superclass’s implementation at the end of your implementation.<br>You should not tie management of system resources to object lifetimes; see Don’t Use dealloc to Manage Scarce Resources.<br>When an application terminates, objects may not be sent a dealloc message. Because the process’s memory is automatically cleared on exit, it is more efficient simply to allow the operating system to clean up resources than to invoke all the memory management methods.</p>
<p>重要提示：不要直接调用另一个对象的dealloc方法。<br>你必须在你自己的实现的结束调用父类的实现。<br>你不可以把系统的资源和对象的生命周期进行绑定。参阅 <a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/MemoryMgmt/Articles/mmPractical.html#//apple_ref/doc/uid/TP40004447-SW13" target="_blank" rel="external">Don’t Use dealloc to Manage Scarce Resources</a><br>当应用程序终止时，对象可能无法发送<code>dealloc</code>消息。因为该方法的内存被自动退出清零，让操作系统清理资源比调用所有的内存管理方法更有效。</p>
</blockquote>
<h2 id="Core-Foundation-Uses-Similar-but-Different-Rules-Core-Foundation使用了类似但不同的规则"><a href="#Core-Foundation-Uses-Similar-but-Different-Rules-Core-Foundation使用了类似但不同的规则" class="headerlink" title="Core Foundation Uses Similar but Different Rules - Core Foundation使用了类似但不同的规则"></a>Core Foundation Uses Similar but Different Rules - <code>Core Foundation</code>使用了类似但不同的规则</h2><p>There are similar memory management rules for Core Foundation objects (see Memory Management Programming Guide for Core Foundation). The naming conventions for Cocoa and Core Foundation, however, are different. In particular, Core Foundation’s Create Rule (see The Create Rule) does not apply to methods that return Objective-C objects. For example, in the following code fragment, you are not responsible for relinquishing ownership of myInstance:</p>
<p>对于 <code>Core Foundation</code> 对象，有一些相似的内存管理规则（参阅 <a href="https://developer.apple.com/library/ios/documentation/CoreFoundation/Conceptual/CFMemoryMgmt/CFMemoryMgmt.html#//apple_ref/doc/uid/10000127i" target="_blank" rel="external">Memory Management Programming Guide for Core Foundation</a>）。但是 对于 Cocoa 和 Core Foundation 命名规则是不同的。具体说,就是 Core Foundatoin 的创建规则，并不适用于返回Objective-C的对象的方法。 例如，在下面的代码片段，你没有责任或义务来释放对 myInstance 的所有权:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyClass *myInstance = [MyClass createInstance];</span><br></pre></td></tr></table></figure>
<h1 id="内存管理实践"><a href="#内存管理实践" class="headerlink" title="内存管理实践"></a>内存管理实践</h1><p>Although the fundamental concepts described in Memory Management Policy are straightforward, there are some practical steps you can take to make managing memory easier, and to help to ensure your program remains reliable and robust while at the same time minimizing its resource requirements.</p>
<p>虽然在<a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/MemoryMgmt/Articles/mmRules.html#//apple_ref/doc/uid/20000994-BAJHFBGH" target="_blank" rel="external">Memory Management Policy</a> 中描述的基本概念很简单，有一些实际的步骤，你可以使内存管理更容易，并帮助确保您的程序是可靠的和鲁棒性的同时减少资源需求。</p>
<h2 id="Use-Accessor-Methods-to-Make-Memory-Management-Easier-使用访问器方法使内存管理更容易"><a href="#Use-Accessor-Methods-to-Make-Memory-Management-Easier-使用访问器方法使内存管理更容易" class="headerlink" title="Use Accessor Methods to Make Memory Management Easier - 使用访问器方法使内存管理更容易"></a>Use Accessor Methods to Make Memory Management Easier - 使用访问器方法使内存管理更容易</h2><p>If your class has a property that is an object, you must make sure that any object that is set as the value is not deallocated while you’re using it. You must therefore claim ownership of the object when it is set. You must also make sure you then relinquish ownership of any currently-held value.</p>
<p>Sometimes it might seem tedious or pedantic, but if you use accessor methods consistently, the chances of having problems with memory management decrease considerably. If you are using retain and release on instance variables throughout your code, you are almost certainly doing the wrong thing.</p>
<p>Consider a Counter object whose count you want to set.</p>
<p>如果你的类有一个属性是一个对象，你必须确保，当你使用它，被设置为值的任何对象都不释放。 因此，当它被设置时，必须声明对象的所有权。你还必须保证对这些对象 所有权的放弃。</p>
<p>有时候似乎很麻烦，如果你坚持用 <code>get</code> 和 <code>set</code> 这种方法方法来实现，那么内存管理的问题出现几率就大幅度减少了。如果对于整个代码的实例变量，使用的是<code>retain</code>和<code>release</code>，你几乎可以肯定是在做错误的事情。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Counter</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, retain) <span class="built_in">NSNumber</span> *count;</span><br><span class="line"><span class="keyword">@end</span>;</span><br></pre></td></tr></table></figure>
<p>The property declares two accessor methods. Typically, you should ask the compiler to synthesize the methods; however, it’s instructive to see how they might be implemented.</p>
<p>In the “get” accessor, you just return the synthesized instance variable, so there is no need for retain or release:</p>
<p>属性声明了两个访问器方法。通常情况下，你应该要求编译器来 <code>synthesize</code> 这些方法；但是，看一下它们可能被实现的形式是有帮助的。</p>
<p>在 <code>get</code> 访问器，就是返回 <code>synthesized</code>实例变量，所以没有必要<code>retain</code>或<code>release</code> ：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSNumber</span> *)count &#123;</span><br><span class="line">    <span class="keyword">return</span> _count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>In the “set” method, if everyone else is playing by the same rules you have to assume the new count may be disposed of at any time so you have to take ownership of the object—by sending it a retain message—to ensure it won’t be. You must also relinquish ownership of the old count object here by sending it a release message. (Sending a message to nil is allowed in Objective-C, so the implementation will still work if _count hasn’t yet been set.) You must send this after [newCount retain] in case the two are the same object—you don’t want to inadvertently cause it to be deallocated.</p>
<p><code>set</code>方法中，如果每个人都遵守相同的规则，你必须承担起新的计数可在任何时间进行设置，所以你必须通过发送一个<code>retain</code>的消息确保它不会被销毁，来维持住对象的所有权。此外，还必须通过发送一个 <code>release</code> 消息放弃老的计数对象在这里的所有权。（在Objective-C发送消息 <code>nil</code> 是允许的，所以如果实现，因此就算_count 还没有旧值,也不会出错。）你必须 在[newCount retain]之后再(对旧值)发送 release，因为你不想因为意外而造成 dealloc。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setCount:(<span class="built_in">NSNumber</span> *)newCount &#123;</span><br><span class="line">    [newCount retain];</span><br><span class="line">    [_count release];</span><br><span class="line">    <span class="comment">// Make the new assignment.</span></span><br><span class="line">    _count = newCount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Use-Accessor-Methods-to-Set-Property-Values-使用访问器方法来设置属性值"><a href="#Use-Accessor-Methods-to-Set-Property-Values-使用访问器方法来设置属性值" class="headerlink" title="Use Accessor Methods to Set Property Values - 使用访问器方法来设置属性值"></a>Use Accessor Methods to Set Property Values - 使用访问器方法来设置属性值</h3><p>Suppose you want to implement a method to reset the counter. You have a couple of choices. The first implementation creates the NSNumber instance with alloc, so you balance that with a release.</p>
<p>假设你想实现复位计数器的方法。你有几个选择。第一种做法就是用 <code>alloc</code> 来新建一个 <code>NSNumber</code> 实例，然后再对应一个 <code>release</code> 。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)reset &#123;</span><br><span class="line">    <span class="built_in">NSNumber</span> *zero = [[<span class="built_in">NSNumber</span> alloc] initWithInteger:<span class="number">0</span>];</span><br><span class="line">    [<span class="keyword">self</span> setCount:zero];</span><br><span class="line">    [zero release];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The second uses a convenience constructor to create a new NSNumber object. There is therefore no need for retain or release messages</p>
<p>第二个使用快速构造器来创建一个新 <code>NSNumber</code> 对象。 因此，不需要 <code>retain</code> 或 <code>release</code> 消息</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)reset &#123;</span><br><span class="line">    <span class="built_in">NSNumber</span> *zero = [<span class="built_in">NSNumber</span> numberWithInteger:<span class="number">0</span>];</span><br><span class="line">    [<span class="keyword">self</span> setCount:zero];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Note that both use the set accessor method.</p>
<p>The following will almost certainly work correctly for simple cases, but as tempting as it may be to eschew accessor methods, doing so will almost certainly lead to a mistake at some stage (for example, when you forget to retain or release, or if the memory management semantics for the instance variable change).</p>
<p>需要注意的是两者都使用set访问方法。</p>
<p>下面的做法,对于简单的情况而言,肯定是没问题的。但是,因为它的实现绕开了 set 方法, 那么在特定情况下会导致错误（例如，比如当你忘记了 retain 或者 release，或者如果实例变量的内存管理发生了变化）。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)reset &#123;</span><br><span class="line">    <span class="built_in">NSNumber</span> *zero = [[<span class="built_in">NSNumber</span> alloc] initWithInteger:<span class="number">0</span>];</span><br><span class="line">    [_count release];</span><br><span class="line">    _count = zero;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Note also that if you are using key-value observing, then changing the variable in this way is not KVO compliant.</p>
<p>还需要注意的是，如果你使用 <a href="https://developer.apple.com/library/ios/documentation/General/Conceptual/DevPedia-CocoaCore/KVO.html#//apple_ref/doc/uid/TP40008195-CH16" target="_blank" rel="external">key-value observing</a>，那么这种对于值的复位就跟 KVO 不 兼容了。</p>
<h3 id="Don’t-Use-Accessor-Methods-in-Initializer-Methods-and-dealloc-不要在初始化方法和-dealloc中使用访问器方法"><a href="#Don’t-Use-Accessor-Methods-in-Initializer-Methods-and-dealloc-不要在初始化方法和-dealloc中使用访问器方法" class="headerlink" title="Don’t Use Accessor Methods in Initializer Methods and dealloc - 不要在初始化方法和 dealloc中使用访问器方法"></a>Don’t Use Accessor Methods in Initializer Methods and dealloc - 不要在初始化方法和 <code>dealloc</code>中使用访问器方法</h3><p>The only places you shouldn’t use accessor methods to set an instance variable are in initializer methods and dealloc. To initialize a counter object with a number object representing zero, you might implement an init method as follows:</p>
<p>你不应该使用存取方法来设置实例变量的唯一地方是在初始化方法和<code>dealloc</code> 。为了初始化一个 counter,并将值设置为 <code>0</code>，你可以实现一个初始化方法如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- init &#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">        _count = [[<span class="built_in">NSNumber</span> alloc] initWithInteger:<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>To allow a counter to be initialized with a count other than zero, you might implement an initWithCount: method as follows:</p>
<p>为了让 counter 的初始化值为非 0 值,你可以实现一个名为 <code>initWithCount:</code>的方法:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- initWithCount:(<span class="built_in">NSNumber</span> *)startingCount &#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">        _count = [startingCount <span class="keyword">copy</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Since the Counter class has an object instance variable, you must also implement a dealloc method. It should relinquish ownership of any instance variables by sending them a release message, and ultimately it should invoke super’s implementation:</p>
<p>由于计数器类有一个对象的实例变量，还必须实现一个dealloc方法。它应该通过发送一个<code>release</code>消息放弃任何实例变量的所有权，最终也应该调用父类的实现：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)dealloc &#123;</span><br><span class="line">    [_count release];</span><br><span class="line">    [<span class="keyword">super</span> dealloc];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Use-Weak-References-to-Avoid-Retain-Cycles-使用弱引用来避免所有权的死锁"><a href="#Use-Weak-References-to-Avoid-Retain-Cycles-使用弱引用来避免所有权的死锁" class="headerlink" title="Use Weak References to Avoid Retain Cycles - 使用弱引用来避免所有权的死锁"></a>Use Weak References to Avoid Retain Cycles - 使用弱引用来避免所有权的死锁</h2><p>Retaining an object creates a strong reference to that object. An object cannot be deallocated until all of its strong references are released. A problem, known as a retain cycle, can therefore arise if two objects may have cyclical references—that is, they have a strong reference to each other (either directly, or through a chain of other objects each with a strong reference to the next leading back to the first).</p>
<p>Retain 一个对象,实际是对一个对象的强引用(strong reference)。一个对象在所有的强引用都解除之前,是不能被 dealloc 的，这导致一个被称为“环形持有”的问题:两个对象相互强引用 (可能是直接引用,也可能是通过其他对象间接地引用。)</p>
<p>The object relationships shown in Figure 1 illustrate a potential retain cycle. The Document object has a Page object for each page in the document. Each Page object has a property that keeps track of which document it is in. If the Document object has a strong reference to the Page object and the Page object has a strong reference to the Document object, neither object can ever be deallocated. The Document’s reference count cannot become zero until the Page object is released, and the Page object won’t be released until the Document object is deallocated.</p>
<p>下图所示的对象关系就构成了一个环形持有。Document 对象持有多个 Page 对象，每个 Page 对象又具有一个 Document 引用来指示它归属的文档。全部 Page 对象都 release 之前,Document 对象的引用数永远不会为 0;而如果 Document 对象存在,Page 对象也无法被 release。</p>
<center><br>    <img src="http://ww3.sinaimg.cn/large/a9c4d5f6gw1f6q04aqj54j20ek0mk0v2.jpg" alt="Figure 1  An illustration of cyclical references"><br></center>

<p>The solution to the problem of retain cycles is to use weak references. A weak reference is a non-owning relationship where the source object does not retain the object to which it has a reference.</p>
<p>环形持有问题的解决方案是使用弱引用。弱引用是一个非持有关系，已经被引用的对象不对它的拥有者进行持有。</p>
<p>To keep the object graph intact, however, there must be strong references somewhere (if there were only weak references, then the pages and paragraphs might not have any owners and so would be deallocated). Cocoa establishes a convention, therefore, that a “parent” object should maintain strong references to its “children,” and that the children should have weak references to their parents.</p>
<p>为了实现上面的对象图,肯定是需要强引用的（如果只有弱引用,那么 Page 和 Paragraph 就没有了持有者，造成他们不会被 dealloc），因此 <code>Cocoa</code> 建立了一个约定，父对象应该维持对于其子对象的强引用，并且子对象应该只对父对象建立弱引用。</p>
<p>So, in Figure 1 the document object has a strong reference to (retains) its page objects, but the page object has a weak reference to (does not retain) the document object.</p>
<p>所以，图1种 <code>document</code> 对象对 <code>page</code> 有一个强引用（retains），但是<code>page</code>对象对 <code>document</code> 对象有一个弱引用（不是 <code>retain</code>）。</p>
<p>Examples of weak references in Cocoa include, but are not restricted to, table data sources, outline view items, notification observers, and miscellaneous targets and delegates.</p>
<p>在 <code>Cocoa</code> 中包含了弱引用的例子，但不限于，表中的数据源，大纲视图项， <code>notification</code> 观察员，以及其他的 target 以及 delegate。</p>
<p>You need to be careful about sending messages to objects for which you hold only a weak reference. If you send a message to an object after it has been deallocated, your application will crash. You must have well-defined conditions for when the object is valid. In most cases, the weak-referenced object is aware of the other object’s weak reference to it, as is the case for circular references, and is responsible for notifying the other object when it deallocates. For example, when you register an object with a notification center, the notification center stores a weak reference to the object and sends messages to it when the appropriate notifications are posted. When the object is deallocated, you need to unregister it with the notification center to prevent the notification center from sending any further messages to the object, which no longer exists. Likewise, when a delegate object is deallocated, you need to remove the delegate link by sending a setDelegate: message with a nil argument to the other object. These messages are normally sent from the object’s dealloc method.</p>
<p>你必须小心将消息发送到您持有只是一个弱引用的对象。当你发送消息给一个被 dealloc 的弱引用对象时，你的应用程序会崩溃。因此,你必须细致地判断对象是否有效。多数情况下,被弱引用的对象是知道其 他对象对它的弱引用的(比如环形持有的情形)，所以需要通知其他对象它自己的 dealloc。举例, 当你向Notification Center 注册一个对象时,Notification Center对这个对象是弱引用的，并且在有消息需要通知到这个对象时，就发送消息给这个对象。当这个对象 dealloc 的时候，你必须向 Notification Center 取消这个对象的注册。这样，这个 Notification Center 就不会再发送消息给这个 不存在的对象了。同样,当一个 delegate 对象被 dealloc 的时候，必须向其他对象发送一个 setDelegate:消息，并传递 nil 参数，从而将代理的关系撤销。这些消息通常在对象的 dealloc 方法中发出。</p>
<h2 id="Avoid-Causing-Deallocation-of-Objects-You’re-Using-避免你正在使用的对象被-dealloc"><a href="#Avoid-Causing-Deallocation-of-Objects-You’re-Using-避免你正在使用的对象被-dealloc" class="headerlink" title="Avoid Causing Deallocation of Objects You’re Using - 避免你正在使用的对象被 dealloc"></a>Avoid Causing Deallocation of Objects You’re Using - 避免你正在使用的对象被 dealloc</h2><p>Cocoa’s ownership policy specifies that received objects should typically remain valid throughout the scope of the calling method. It should also be possible to return a received object from the current scope without fear of it being released. It should not matter to your application that the getter method of an object returns a cached instance variable or a computed value. What matters is that the object remains valid for the time you need it.</p>
<p><code>Cocoa</code> 的所有权策略规定，收到的对象通常应该在整个调用方法的范围仍然有效。这也应该是在当前方法内部，不必担心你收到的返回对象会被 <code>dealloc</code> 。对象的 getter 方法返回一个被缓存的实例或者一个计算出来的值，这并不重要，重要的是这个对象在你使用它的时候会一直有效。</p>
<p>There are occasional exceptions to this rule, primarily falling into one of two categories.</p>
<p>偶尔有例外的情况，主要分为两类：</p>
<p>When an object is removed from one of the fundamental collection classes.</p>
<ol>
<li>当一个对象从 <a href="https://developer.apple.com/library/prerelease/content/documentation/General/Conceptual/DevPedia-CocoaCore/Collection.html#//apple_ref/doc/uid/TP40008195-CH10-SW2" target="_blank" rel="external">collection classes</a> 中删除的时候。</li>
</ol>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">heisenObject = [array objectAtIndex:n];</span><br><span class="line">[array removeObjectAtIndex:n];</span><br><span class="line"><span class="comment">// heisenObject could now be invalid.</span></span><br></pre></td></tr></table></figure>
<p>When an object is removed from one of the fundamental collection classes, it is sent a release (rather than autorelease) message. If the collection was the only owner of the removed object, the removed object (heisenObject in the example ) is then immediately deallocated.</p>
<p>当一个对象从基本集合类之一删除，它发送一个 <code>release</code> （而不是 <code>autorelease</code> ）消息。如果集合是被删除对象的唯一拥有者，被移除的对象是立即被释放。</p>
<p>When a “parent object” is deallocated.</p>
<ol>
<li>当一个“父对象”被释放。</li>
</ol>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">id</span> parent = &lt;<span class="meta">#create a parent object#&gt;;</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">heisenObject = [parent child] ;</span><br><span class="line">[parent release]; <span class="comment">// Or, for example: self.parent = nil;</span></span><br><span class="line"><span class="comment">// heisenObject could now be invalid.</span></span><br></pre></td></tr></table></figure>
<p>In some situations you retrieve an object from another object, and then directly or indirectly release the parent object. If releasing the parent causes it to be deallocated, and the parent was the only owner of the child, then the child (heisenObject in the example) will be deallocated at the same time (assuming that it is sent a release rather than an autorelease message in the parent’s dealloc method).</p>
<p>在某些情况下检索来自另一个对象的对象，然后直接或间接地释放父对象。如果释放父对象导致它被释放，并且父对象是子对象的唯一所有者，那么子对象（例子中的heisenObject）将在同一时间被释放（假设在父类中的 <code>dealloc</code> 方法中，给子对象发送的是 <code>release</code> 消息，而不是 <code>autolease</code> 消息）</p>
<p>To protect against these situations, you retain heisenObject upon receiving it and you release it when you have finished with it. For example:</p>
<p>为了防止这种情况下，你可以在接收到heisenObject 的时候 <code>retain</code> 一次，并且当你用完的时候 ，<code>release</code>。例如：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">heisenObject = [[array objectAtIndex:n] retain];</span><br><span class="line">[array removeObjectAtIndex:n];</span><br><span class="line"><span class="comment">// Use heisenObject...</span></span><br><span class="line">[heisenObject release];</span><br></pre></td></tr></table></figure>
<h2 id="Don’t-Use-dealloc-to-Manage-Scarce-Resources-不要使用-dealloc-来管理关键系统资源"><a href="#Don’t-Use-dealloc-to-Manage-Scarce-Resources-不要使用-dealloc-来管理关键系统资源" class="headerlink" title="Don’t Use dealloc to Manage Scarce Resources - 不要使用 dealloc 来管理关键系统资源"></a>Don’t Use dealloc to Manage Scarce Resources - 不要使用 <code>dealloc</code> 来管理关键系统资源</h2><p>You should typically not manage scarce resources such as file descriptors, network connections, and buffers or caches in a dealloc method. In particular, you should not design classes so that dealloc will be invoked when you think it will be invoked. Invocation of dealloc might be delayed or sidestepped, either because of a bug or because of application tear-down.</p>
<p>通常，你不应该在 dealloc 中来管理稀缺系统资源，比如文件描述符、网络连接、缓存等。尤其注意，你不应该这样设计类：你想让系统什么时候调用 dealloc，系统就什么时候调用。<code>dealloc</code> 的调用可能会被推迟或者搁置，比如因为 <code>bug</code> 或者系统性能下降。</p>
<p>Instead, if you have a class whose instances manage scarce resources, you should design your application such that you know when you no longer need the resources and can then tell the instance to “clean up” at that point. You would typically then release the instance, and dealloc would follow, but you will not suffer additional problems if it does not.</p>
<p>相反，如果你有一个类，管理了稀缺资源，它就必须知道它什么时候不再需要这些资源,并在此时立即释放资源。通常情况下,此时,你会调用 release 来 dealloc,但是因 为此前你已经释放了资源,这里就不会遇到任何问题。</p>
<p>Problems may arise if you try to piggy-back resource management on top of dealloc. For example:</p>
<p>如果你尝试把资源管理问题的职能交给 <code>dealloc</code> ，可能会导致很多问题，比如：</p>
<ul>
<li>Order dependencies on object graph tear-down.</li>
</ul>
<p>The object graph tear-down mechanism is inherently non-ordered. Although you might typically expect—and get—a particular order, you are introducing fragility. If an object is unexpectedly autoreleased rather than released for example, the tear-down order may change, which may lead to unexpected results.</p>
<ul>
<li>Non-reclamation of scarce resources.</li>
</ul>
<p>Memory leaks are bugs that should be fixed, but they are generally not immediately fatal. If scarce resources are not released when you expect them to be released, however, you may run into more serious problems. If your application runs out of file descriptors, for example, the user may not be able to save data.</p>
<ul>
<li>Cleanup logic being executed on the wrong thread.</li>
</ul>
<p>If an object is autoreleased at an unexpected time, it will be deallocated on whatever thread’s autorelease pool block it happens to be in. This can easily be fatal for resources that should only be touched from one thread.</p>
<ul>
<li>对象图的拆除顺序问题</li>
</ul>
<p>对象图拆卸机制本质上是无序的。尽管你可能通常希望和获得一个特定的顺序。例如，如果一个对象被意外地 <code>autorelease</code> ，而不是 <code>release</code> ，拆卸顺序可能改变，这可能会导致意想不到的结果。</p>
<ul>
<li>系统稀缺资源不能回收</li>
</ul>
<p>内存泄漏是应该被修复的 <code>bugs</code>，但他们一般都不会是立即致命的。然而，如果当你希望稀缺资源被释放，但没有释放，你可能会遇到更严重的问题。例如，如果你的应用程序运行了文件描述符，用户可能无法保存数据。</p>
<ul>
<li>释放资源的操作被错误的线程执行</li>
</ul>
<p>如果对象是在一个意想不到的时间自动释放，它将被线程池中的线程来 dealloc。对于只能从一个线程操作的资源来说，这很容易造成致命的后果。</p>
<h2 id="Collections-Own-the-Objects-They-Contain-Collections-拥有他们所包含的对象"><a href="#Collections-Own-the-Objects-They-Contain-Collections-拥有他们所包含的对象" class="headerlink" title="Collections Own the Objects They Contain - Collections 拥有他们所包含的对象"></a>Collections Own the Objects They Contain - <code>Collections</code> 拥有他们所包含的对象</h2><p>When you add an object to a collection (such as an array, dictionary, or set), the collection takes ownership of it. The collection will relinquish ownership when the object is removed from the collection or when the collection is itself released. Thus, for example, if you want to create an array of numbers you might do either of the following:</p>
<p>当您添加一个对象到一个 <a href="https://developer.apple.com/library/ios/documentation/General/Conceptual/DevPedia-CocoaCore/Collection.html#//apple_ref/doc/uid/TP40008195-CH10-SW2" target="_blank" rel="external">collection</a> ，例如（数组，字典，集合），<code>collection</code>会取得该对象的所有权。当对象从集合中删除或当集合本身释放时，集合将放弃所有权。因此，如果你想创建数字数组，可以像下面这样做：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSMutableArray</span> *array = &lt;<span class="meta">#Get a mutable array#&gt;;</span></span><br><span class="line"><span class="built_in">NSUInteger</span> i;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">NSNumber</span> *convenienceNumber = [<span class="built_in">NSNumber</span> numberWithInteger:i];</span><br><span class="line">    [array addObject:convenienceNumber];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>In this case, you didn’t invoke alloc, so there’s no need to call release. There is no need to retain the new numbers (convenienceNumber), since the array will do so.</p>
<p>在这种情况下，你没有调用alloc ，所以没有必要调用release 。 没有必要保留新numbers（ convenienceNumber ），因为数组会这么做。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSMutableArray</span> *array = &lt;<span class="meta">#Get a mutable array#&gt;;</span></span><br><span class="line"><span class="built_in">NSUInteger</span> i;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">NSNumber</span> *allocedNumber = [[<span class="built_in">NSNumber</span> alloc] initWithInteger:i];</span><br><span class="line">    [array addObject:allocedNumber];</span><br><span class="line">    [allocedNumber release];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>In this case, you do need to send allocedNumber a release message within the scope of the for loop to balance the alloc. Since the array retained the number when it was added by addObject:, it will not be deallocated while it’s in the array.</p>
<p>这种做法,我们在 for 循环内部向 <code>allocedNumber</code> 发送了与 <code>alloc</code> 相对应的 <code>release</code> 消息。因为Array 的 <code>addObject:</code> 方法实际上对这个对象做了 <code>retain</code> 处理,那么这个对象(allocedNumber)不会因此而被 <code>dealloc</code>。</p>
<p>To understand this, put yourself in the position of the person who implemented the collection class. You want to make sure that no objects you’re given to look after disappear out from under you, so you send them a retain message as they’re passed in. If they’re removed, you have to send a balancing release message, and any remaining objects should be sent a release message during your own dealloc method.</p>
<p>要理解这一点，把自己放在那些实现集合类的人的位置。你要确保加入的对象只要继续 存在于 Collection 里,就不应该被 dealloc,因此你在添加这个对象时,向它发送了 retain 消息,删 除这个对象时,向它发送了 release 消息。当你这个 collection 类自己 dealloc 时,对容器内所有的 对象发 release。</p>
<h2 id="Ownership-Policy-Is-Implemented-Using-Retain-Counts-通过引用计数实现所有权策略"><a href="#Ownership-Policy-Is-Implemented-Using-Retain-Counts-通过引用计数实现所有权策略" class="headerlink" title="Ownership Policy Is Implemented Using Retain Counts - 通过引用计数实现所有权策略"></a>Ownership Policy Is Implemented Using Retain Counts - 通过引用计数实现所有权策略</h2><p>The ownership policy is implemented through reference counting—typically called “retain count” after the retain method. Each object has a retain count.</p>
<ul>
<li>When you create an object, it has a retain count of 1.</li>
<li>When you send an object a retain message, its retain count is incremented by 1.</li>
<li>When you send an object a release message, its retain count is decremented by 1.</li>
<li>When you send an object a autorelease message, its retain count is decremented by 1 at the end of the current autorelease pool block.</li>
<li>If an object’s retain count is reduced to zero, it is deallocated.</li>
</ul>
<p>所有权政策是通过引用计数实现的，通常retain方法后被称为“retain count”后。每个对象都有一个引用计数。</p>
<ul>
<li>当你创建一个对象，它有一个保留计数 1。</li>
<li>当你给对象发送一个 <code>retain</code> 。保留计数 +1</li>
<li>当你给对象发送一个 <code>release</code> 消息，它的保留计数 -1</li>
<li>当你给对象发送一个 <code>autorelease</code> 消息。它的保留计数在当前自动释放池块结束后 -1</li>
<li>如果对象的保留计数减少到 0，它被释放。</li>
</ul>
<blockquote>
<p>Important: There should be no reason to explicitly ask an object what its retain count is (see retainCount). The result is often misleading, as you may be unaware of what framework objects have retained an object in which you are interested. In debugging memory management issues, you should be concerned only with ensuring that your code adheres to the ownership rules.</p>
<p>重要:其实你应该没有理由想知道一个对象的 retain count。这个数值有时候会造成对你的误导：你不知道实际上有些系统框架的对象会对你关注的那个对象进行retain。在调试内存问题的时候，你只需要遵守所有权规则就行了。</p>
</blockquote>
<h1 id="Using-Autorelease-Pool-Blocks-使用自动释放池块"><a href="#Using-Autorelease-Pool-Blocks-使用自动释放池块" class="headerlink" title="Using Autorelease Pool Blocks - 使用自动释放池块"></a>Using Autorelease Pool Blocks - 使用自动释放池块</h1><p>Autorelease pool blocks provide a mechanism whereby you can relinquish ownership of an object, but avoid the possibility of it being deallocated immediately (such as when you return an object from a method). Typically, you don’t need to create your own autorelease pool blocks, but there are some situations in which either you must or it is beneficial to do so.</p>
<p>自动释放池块提供了一种机制，让你可以放弃对象的所有权，但要避免它被立即释放的可能性（例如，当您从一个方法返回一个对象）。通常情况下，你不需要创建自己的自动释放池块，但也有一些情况，需要自行创建。</p>
<h2 id="About-Autorelease-Pool-Blocks-关于自动释放池块"><a href="#About-Autorelease-Pool-Blocks-关于自动释放池块" class="headerlink" title="About Autorelease Pool Blocks - 关于自动释放池块"></a>About Autorelease Pool Blocks - 关于自动释放池块</h2><p>An autorelease pool block is marked using @autoreleasepool, as illustrated in the following example:</p>
<p>自动释放池块使用标记 <code>@autoreleasepool</code> ，如下面的示例所示：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">    <span class="comment">// Code that creates autoreleased objects.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>At the end of the autorelease pool block, objects that received an autorelease message within the block are sent a release message—an object receives a release message for each time it was sent an autorelease message within the block.</p>
<p>在 autorelease 池被 dealloc 的时候,它自己会给容纳的所有对象发送 release 消息。一个对象可以被多次放到同一个 autorelease 池,每一次放入(发送 autorelease 消息)都会造成将来收到一次 release。</p>
<p>Like any other code block, autorelease pool blocks can be nested:</p>
<p>像任何其他代码块，自动释放池块可以嵌套：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">    <span class="comment">// . . .</span></span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="comment">// . . .</span></span><br><span class="line">    &#125;</span><br><span class="line">    . . .</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(You wouldn’t normally see code exactly as above; typically code within an autorelease pool block in one source file would invoke code in another source file that is contained within another autorelease pool block.) For a given autorelease message, the corresponding release message is sent at the end of the autorelease pool block in which the autorelease message was sent.</p>
<p>Cocoa always expects code to be executed within an autorelease pool block, otherwise autoreleased objects do not get released and your application leaks memory. (If you send an autorelease message outside of an autorelease pool block, Cocoa logs a suitable error message.) The AppKit and UIKit frameworks process each event-loop iteration (such as a mouse down event or a tap) within an autorelease pool block. Therefore you typically do not have to create an autorelease pool block yourself, or even see the code that is used to create one. There are, however, three occasions when you might use your own autorelease pool blocks:</p>
<ul>
<li>If you are writing a program that is not based on a UI framework, such as a command-line tool.</li>
<li><p>If you write a loop that creates many temporary objects.<br>You may use an autorelease pool block inside the loop to dispose of those objects before the next iteration. Using an autorelease pool block in the loop helps to reduce the maximum memory footprint of the application.</p>
</li>
<li><p>If you spawn a secondary thread.<br>You must create your own autorelease pool block as soon as the thread begins executing; otherwise, your application will leak objects. (See Autorelease Pool Blocks and Threads for details.)</p>
</li>
</ul>
<p>（你不会经常看到像上面那样的代码；通常在一个源文件自动释放池块中的代码将调用包含在另一个自动释放池块中的另一个源文件的代码。）对于给定的 <code>autorelease的</code> 消息，相应的 <code>release</code> 消息在该 <code>autorelease</code> 池块结束时发送 <code>autorelease</code> 消息。</p>
<p><code>Cocoa</code> 总是代码是在一个自动释放池块执行，否则自动释放对象没有得到释放，你的应用程序的内存泄露。（如果在自动释放池外面发送一个 <code>autorelease</code> 消息，<code>Cocoa</code> 会记录适当的错误信息）<code>AppKit</code> 和 <code>UIKit</code> 框架处理每个事件循环迭代（如鼠标按下事件或触摸）都在自动释放池块中。因此，你一般不必创建一个自动释放池，甚至不需要知道创建 autorelease 池的代码如何写。但是，三种情况时可能会使用自己的自动释放池块：</p>
<ul>
<li>如果你正在写的不是基于一个UI框架，比如一个命令行工具的程序。</li>
<li>如果你写一个循环，创建的临时对象。</li>
</ul>
<p>你可以在循环体内部新建一个 autorelease 池,并在一次循环结束时销毁这些临时对象。这样 可以减少你的程序对内存的占用峰值。</p>
<ul>
<li>如果您生成一个辅助线程。</li>
</ul>
<p>必须尽快建立自己的自动释放池块线程开始执行; 否则，你的应用程序会泄漏的对象。 (见 <a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/MemoryMgmt/Articles/mmAutoreleasePools.html#//apple_ref/doc/uid/20000047-1041876" target="_blank" rel="external">Autorelease Pool Blocks and Threads</a>)</p>
<h2 id="Use-Local-Autorelease-Pool-Blocks-to-Reduce-Peak-Memory-Footprint-使用本地自动释放池块，降低峰值内存占用"><a href="#Use-Local-Autorelease-Pool-Blocks-to-Reduce-Peak-Memory-Footprint-使用本地自动释放池块，降低峰值内存占用" class="headerlink" title="Use Local Autorelease Pool Blocks to Reduce Peak Memory Footprint - 使用本地自动释放池块，降低峰值内存占用"></a>Use Local Autorelease Pool Blocks to Reduce Peak Memory Footprint - 使用本地自动释放池块，降低峰值内存占用</h2><p>Many programs create temporary objects that are autoreleased. These objects add to the program’s memory footprint until the end of the block. In many situations, allowing temporary objects to accumulate until the end of the current event-loop iteration does not result in excessive overhead; in some situations, however, you may create a large number of temporary objects that add substantially to memory footprint and that you want to dispose of more quickly. In these latter cases, you can create your own autorelease pool block. At the end of the block, the temporary objects are released, which typically results in their deallocation thereby reducing the program’s memory footprint.</p>
<p>许多程序创建的临时对象被自动释放。这些对象添加到程序的内存占用，直到块的末端。在许多情况下，允许临时对象累积，直到当前的事件循环迭代结束时没有过多的开销；但在有些情况下，你可能会创建大量的临时对象，大幅增加内存占用，并且你想更加快速的销毁。在后一种情况下，你可以创建自己的自动释放池块。在该块的结束时，临时对象被释放，通常导致其释放，从而减少了程序的内存占用。</p>
<p>The following example shows how you might use a local autorelease pool block in a for loop.</p>
<p>下面的例子说明了如何在 for 循环中使用本地自动释放池块</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSArray</span> *urls = &lt;<span class="meta"># An array of file URLs #&gt;;</span></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">NSURL</span> *url <span class="keyword">in</span> urls) &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="built_in">NSError</span> *error;</span><br><span class="line">        <span class="built_in">NSString</span> *fileContents = [<span class="built_in">NSString</span> stringWithContentsOfURL:url</span><br><span class="line">                                         encoding:<span class="built_in">NSUTF8StringEncoding</span> error:&amp;error];</span><br><span class="line">        <span class="comment">/* Process the string, creating and autoreleasing more objects. */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The for loop processes one file at a time. Any object (such as fileContents) sent an autorelease message inside the autorelease pool block is released at the end of the block.</p>
<p>for循环一次处理一个文件。自动释放池块中的任何对象（如fileContents）发送的autorelease消息，是在块的结尾释放。</p>
<p>After an autorelease pool block, you should regard any object that was autoreleased within the block as “disposed of.” Do not send a message to that object or return it to the invoker of your method. If you must use a temporary object beyond an autorelease pool block, you can do so by sending a retain message to the object within the block and then send it autorelease after the block, as illustrated in this example:</p>
<p>自动释放池块后，你应该把对该块作为自动释放任何物体“进行处理。”不要发送消息到该对象或将其返回到你的方法的调用。 如果你必须在自动释放池块外部使用一个临时对象，你可以在块内发送一个 <code>retain</code> 消息，然后再块之后发送 <code>autorelease</code>， 如本例所示：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">– (<span class="keyword">id</span>)findMatchingObject:(<span class="keyword">id</span>)anObject &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">id</span> match;</span><br><span class="line">    <span class="keyword">while</span> (match == <span class="literal">nil</span>) &#123;</span><br><span class="line">        <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line"> </span><br><span class="line">            <span class="comment">/* Do a search that creates a lot of temporary objects. */</span></span><br><span class="line">            match = [<span class="keyword">self</span> expensiveSearchForObject:anObject];</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">if</span> (match != <span class="literal">nil</span>) &#123;</span><br><span class="line">                [match retain]; <span class="comment">/* Keep match around. */</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> [match autorelease];   <span class="comment">/* Let match go and return it. */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Sending retain to match within the autorelease pool block the and sending autorelease to it after the autorelease pool block extends the lifetime of match and allows it to receive messages outside the loop and be returned to the invoker of findMatchingObject:.</p>
<p>在自动释放池块中发送 <code>retain</code> 给 match，并在自动释放池块后发送 <code>autorelease</code>，拓展了match 的生命周期，并允许它在循环外接收消息并返回到 <code>findMatchingObject:</code> 的调用者。</p>
<h2 id="Autorelease-Pool-Blocks-and-Threads-自动释放池块和线程"><a href="#Autorelease-Pool-Blocks-and-Threads-自动释放池块和线程" class="headerlink" title="Autorelease Pool Blocks and Threads - 自动释放池块和线程"></a>Autorelease Pool Blocks and Threads - 自动释放池块和线程</h2><p>Each thread in a Cocoa application maintains its own stack of autorelease pool blocks. If you are writing a Foundation-only program or if you detach a thread, you need to create your own autorelease pool block.</p>
<p>在 <code>Cocoa</code> 应用程序中的每个线程维护其自己的自动释放池块栈。 如果你写的仅仅是一个基于 <code>Foundation</code> 的程序，或者 <code>detach</code> 一个线程，你需要创建自己的自动释放池块。</p>
<p>If your application or thread is long-lived and potentially generates a lot of autoreleased objects, you should use autorelease pool blocks (like AppKit and UIKit do on the main thread); otherwise, autoreleased objects accumulate and your memory footprint grows. If your detached thread does not make Cocoa calls, you do not need to use an autorelease pool block.</p>
<p>如果您的应用程序或线程是长期存在并可能产生大量的自动释放的对象，你应该使用自动释放池块(例如AppKit和UIKit在主线程上工作）；否则，自动释放对象不断累积，内存占用量的增长。如果你的独立线程不让<code>Cocoa</code> 调用，你不需要使用自动释放池块。</p>
<blockquote>
<p>Note: If you create secondary threads using the POSIX thread APIs instead of NSThread, you cannot use Cocoa unless Cocoa is in multithreading mode. Cocoa enters multithreading mode only after detaching its first NSThread object. To use Cocoa on secondary POSIX threads, your application must first detach at least one NSThread object, which can immediately exit. You can test whether Cocoa is in multithreading mode with the NSThread class method isMultiThreaded.</p>
<p>注意：如果您创建一个使用POSIX线程的API，而不是辅助线程 <code>NSThread</code>，您不能使用Cocoa，除非Cocoa在多线程模式。 为了在辅助 <code>POSIX</code> 线程上使用 Cocoa ，你的应用程序必须先至少 <code>detach</code> 一个可以立即退出的 <code>NSThread</code> 对象。使用 <code>NSThread</code> 类方法 <a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSThread_Class/index.html#//apple_ref/occ/clm/NSThread/isMultiThreaded" target="_blank" rel="external">isMultiThreaded</a> 测试 Cocoa 是否是多线程模式。</p>
</blockquote>
  
	</div>
		<footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/iOS/">iOS</a>
</div>


</div>



	<div class="article-share" id="share">
	
	  <div data-url="http://yoferzhang.com/post/20160811OCMemoryManagement/" data-title="【iOS】Advanced Memory Management Programming Guide 高级内存管理编程指南(官方文档翻译) | YoferZhang 的博客" data-tsina="2848249334" class="share clearfix">
	  </div>
	
	</div>


</footer>

   	       
	</article>
	
<nav class="article-nav clearfix">
 
 <div class="prev" >
 <a href="/post/20160811OCMemoryManagementSum/" title="【iOS】Objective-C内存管理">
  <strong>上一篇：</strong><br/>
  <span>
  【iOS】Objective-C内存管理</span>
</a>
</div>


<div class="next">
<a href="/post/20160810AboutHTTPLiveStream/"  title="【iOS】About HTTP Live Streaming官方文档翻译">
 <strong>下一篇：</strong><br/> 
 <span>【iOS】About HTTP Live Streaming官方文档翻译
</span>
</a>
</div>

</nav>

	
<section id="comments" class="comment">
	<div class="ds-thread" data-thread-key="post/20160811OCMemoryManagement/" data-title="【iOS】Advanced Memory Management Programming Guide 高级内存管理编程指南(官方文档翻译)" data-url="http://yoferzhang.com/post/20160811OCMemoryManagement/"></div>
</section>


</div>  
      <div class="openaside"><a class="navbutton" href="#" title="显示侧边栏"></a></div>

  <div id="toc" class="toc-aside">
  <strong class="toc-title">文章目录</strong>
 
 <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#About-Memory-Management-关于内存管理"><span class="toc-number">1.</span> <span class="toc-text">About Memory Management - 关于内存管理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#At-a-Glance-简单了解"><span class="toc-number">1.1.</span> <span class="toc-text">At a Glance - 简单了解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Good-Practices-Prevent-Memory-Related-Problems-好的做法，防止内存相关的问题"><span class="toc-number">1.1.1.</span> <span class="toc-text">Good Practices Prevent Memory-Related Problems - 好的做法，防止内存相关的问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Use-Analysis-Tools-to-Debug-Memory-Problems-使用分析工具来调试内存问题"><span class="toc-number">1.1.2.</span> <span class="toc-text">Use Analysis Tools to Debug Memory Problems - 使用分析工具来调试内存问题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Memory-Management-Policy-内存管理策略"><span class="toc-number">2.</span> <span class="toc-text">Memory Management Policy - 内存管理策略</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Basic-Memory-Management-Rules-基本内存管理规则"><span class="toc-number">2.1.</span> <span class="toc-text">Basic Memory Management Rules - 基本内存管理规则</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#A-Simple-Example-一个简单的例子"><span class="toc-number">2.1.1.</span> <span class="toc-text">A Simple Example - 一个简单的例子</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Use-autorelease-to-Send-a-Deferred-release-使用autorelease发送延迟release"><span class="toc-number">2.1.2.</span> <span class="toc-text">Use autorelease to Send a Deferred release - 使用autorelease发送延迟release</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#You-Don’t-Own-Objects-Returned-by-Reference-你没有通过引用返回的对象的所有权"><span class="toc-number">2.1.3.</span> <span class="toc-text">You Don’t Own Objects Returned by Reference - 你没有通过引用返回的对象的所有权</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Implement-dealloc-to-Relinquish-Ownership-of-Objects-实现dealloc放弃对象的所有权"><span class="toc-number">2.2.</span> <span class="toc-text">Implement dealloc to Relinquish Ownership of Objects - 实现dealloc放弃对象的所有权</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Core-Foundation-Uses-Similar-but-Different-Rules-Core-Foundation使用了类似但不同的规则"><span class="toc-number">2.3.</span> <span class="toc-text">Core Foundation Uses Similar but Different Rules - Core Foundation使用了类似但不同的规则</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#内存管理实践"><span class="toc-number">3.</span> <span class="toc-text">内存管理实践</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Use-Accessor-Methods-to-Make-Memory-Management-Easier-使用访问器方法使内存管理更容易"><span class="toc-number">3.1.</span> <span class="toc-text">Use Accessor Methods to Make Memory Management Easier - 使用访问器方法使内存管理更容易</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Use-Accessor-Methods-to-Set-Property-Values-使用访问器方法来设置属性值"><span class="toc-number">3.1.1.</span> <span class="toc-text">Use Accessor Methods to Set Property Values - 使用访问器方法来设置属性值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Don’t-Use-Accessor-Methods-in-Initializer-Methods-and-dealloc-不要在初始化方法和-dealloc中使用访问器方法"><span class="toc-number">3.1.2.</span> <span class="toc-text">Don’t Use Accessor Methods in Initializer Methods and dealloc - 不要在初始化方法和 dealloc中使用访问器方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Use-Weak-References-to-Avoid-Retain-Cycles-使用弱引用来避免所有权的死锁"><span class="toc-number">3.2.</span> <span class="toc-text">Use Weak References to Avoid Retain Cycles - 使用弱引用来避免所有权的死锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Avoid-Causing-Deallocation-of-Objects-You’re-Using-避免你正在使用的对象被-dealloc"><span class="toc-number">3.3.</span> <span class="toc-text">Avoid Causing Deallocation of Objects You’re Using - 避免你正在使用的对象被 dealloc</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Don’t-Use-dealloc-to-Manage-Scarce-Resources-不要使用-dealloc-来管理关键系统资源"><span class="toc-number">3.4.</span> <span class="toc-text">Don’t Use dealloc to Manage Scarce Resources - 不要使用 dealloc 来管理关键系统资源</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Collections-Own-the-Objects-They-Contain-Collections-拥有他们所包含的对象"><span class="toc-number">3.5.</span> <span class="toc-text">Collections Own the Objects They Contain - Collections 拥有他们所包含的对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Ownership-Policy-Is-Implemented-Using-Retain-Counts-通过引用计数实现所有权策略"><span class="toc-number">3.6.</span> <span class="toc-text">Ownership Policy Is Implemented Using Retain Counts - 通过引用计数实现所有权策略</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Using-Autorelease-Pool-Blocks-使用自动释放池块"><span class="toc-number">4.</span> <span class="toc-text">Using Autorelease Pool Blocks - 使用自动释放池块</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#About-Autorelease-Pool-Blocks-关于自动释放池块"><span class="toc-number">4.1.</span> <span class="toc-text">About Autorelease Pool Blocks - 关于自动释放池块</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Use-Local-Autorelease-Pool-Blocks-to-Reduce-Peak-Memory-Footprint-使用本地自动释放池块，降低峰值内存占用"><span class="toc-number">4.2.</span> <span class="toc-text">Use Local Autorelease Pool Blocks to Reduce Peak Memory Footprint - 使用本地自动释放池块，降低峰值内存占用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Autorelease-Pool-Blocks-and-Threads-自动释放池块和线程"><span class="toc-number">4.3.</span> <span class="toc-text">Autorelease Pool Blocks and Threads - 自动释放池块和线程</span></a></li></ol></li></ol>
 
  </div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="隐藏侧边栏"></a></div>
<aside class="clearfix">

  
<div class="github-card">
<p class="asidetitle">Github 名片</p>
<div class="github-card" data-github="yoferzhang" data-width="220" data-height="119" data-theme="medium">
<script type="text/javascript" src="//cdn.jsdelivr.net/github-cards/latest/widget.js" ></script>
</div>
  </div>



  
<div class="categorieslist">
	<p class="asidetitle">分类</p>
		<ul>
		
		  
			<li><a href="/categories/AI/" title="AI">AI<sup>8</sup></a></li>
		  
		
		  
			<li><a href="/categories/C语言/" title="C语言">C语言<sup>3</sup></a></li>
		  
		
		  
			<li><a href="/categories/iOS/" title="iOS">iOS<sup>50</sup></a></li>
		  
		
		  
			<li><a href="/categories/渔/" title="渔">渔<sup>5</sup></a></li>
		  
		
		  
			<li><a href="/categories/艺术/" title="艺术">艺术<sup>6</sup></a></li>
		  
		
		  
			<li><a href="/categories/读书感悟/" title="读书感悟">读书感悟<sup>14</sup></a></li>
		  
		
		  
			<li><a href="/categories/随笔/" title="随笔">随笔<sup>3</sup></a></li>
		  
		
		</ul>
</div>


  <div class="linkslist">
  <p class="asidetitle">友情链接</p>
    <ul>
        
          <li>
            
            	<a href="https://hexo.io/" target="_blank" title="Hexo">Hexo</a>
            
          </li>
        
          <li>
            
            	<a href="https://github.com/yoferzhang" target="_blank" title="Github">Github</a>
            
          </li>
        
          <li>
            
            	<a href="http://ww3.sinaimg.cn/large/a9c4d5f6jw1f2cbilh1uyj2076076t97.jpg" target="_blank" title="WeChat">WeChat</a>
            
          </li>
        
          <li>
            
            	<a href="https://cn.linkedin.com/in/耀琦-张-771388117" target="_blank" title="LinkedIn">LinkedIn</a>
            
          </li>
        
    </ul>
</div>

  <div class="rsspart">
	<a href="/atom.xml" target="_blank" title="rss">RSS 订阅</a>
</div>

</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<section class="info">
		<p> Hello ,I&#39;m Yofer Zhang in Tencent. <br/>
			This is my blog,thank you to here.</p>
	</section>
	 
	<div class="social-font" class="clearfix">
		
		<a href="http://weibo.com/2848249334" target="_blank" class="icon-weibo" title="微博"></a>
		
		
		<a href="https://github.com/yoferzhang" target="_blank" class="icon-github" title="github"></a>
		
		
		<a href="http://stackoverflow.com/users/yofer-zhang" target="_blank" class="icon-stack-overflow" title="stackoverflow"></a>
		
		
		<a href="https://twitter.com/LuciferZhangyq" target="_blank" class="icon-twitter" title="twitter"></a>
		
		
		<a href="https://www.facebook.com/luciferzhang" target="_blank" class="icon-facebook" title="facebook"></a>
		
		
		<a href="https://www.linkedin.com/in/耀琦-张-771388117?trk=hp-identity-name" target="_blank" class="icon-linkedin" title="linkedin"></a>
		
		
		<a href="https://www.douban.com/people/zyq522376829" target="_blank" class="icon-douban" title="豆瓣"></a>
		
		
		<a href="http://www.zhihu.com/people/yoferzhang" target="_blank" class="icon-zhihu" title="知乎"></a>
		
		
		<a href="https://plus.google.com/110295955443575724222?rel=author" target="_blank" class="icon-google_plus" title="Google+"></a>
		
		
		<a href="mailto:522376829@qq.com" target="_blank" class="icon-email" title="Email Me"></a>
		
	</div>
			
		

		<p class="copyright">
		Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/wuchong/jacman" target="_blank" title="Jacman">Jacman</a> © 2018 
		
		<a href="/about" target="_blank" title="Yofer Zhang">Yofer Zhang</a>
		
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/jquery.qrcode-0.12.0.min.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
        getSize();
        if (myWidth >= 1024) {
          c.click();
        }
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
      
      $('#toc.toc-aside').css('display', 'none');
        
    }
  });
});
</script>

<script type="text/javascript">
$(document).ready(function(){ 
  var ai = $('.article-content>iframe'),
      ae = $('.article-content>embed'),
      t  = $('#toc'),
      ta = $('#toc.toc-aside'),
      o  = $('.openaside'),
      c  = $('.closeaside');
  if(ai.length>0){
    ai.wrap('<div class="video-container" />');
  };
  if(ae.length>0){
   ae.wrap('<div class="video-container" />');
  };
  c.click(function(){
    ta.css('display', 'block').addClass('fadeIn');
  });
  o.click(function(){
    ta.css('display', 'none');
  });
  $(window).scroll(function(){
    ta.css("top",Math.max(140,320-$(this).scrollTop()));
  });
});
</script>


<script type="text/javascript">
$(document).ready(function(){ 
  var $this = $('.share'),
      url = $this.attr('data-url'),
      encodedUrl = encodeURIComponent(url),
      title = $this.attr('data-title'),
      tsina = $this.attr('data-tsina'),
      description = $this.attr('description');
  var html = [
  '<div class="hoverqrcode clearfix"></div>',
  '<a class="overlay" id="qrcode"></a>',
  '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
  '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
  '<a href="#qrcode" class="article-share-qrcode" title="微信"></a>',
  '<a href="http://widget.renren.com/dialog/share?resourceUrl=' + encodedUrl + '&srcUrl=' + encodedUrl + '&title=' + title +'" class="article-share-renren" target="_blank" title="人人"></a>',
  '<a href="http://service.weibo.com/share/share.php?title='+title+'&url='+encodedUrl +'&ralateUid='+ tsina +'&searchPic=true&style=number' +'" class="article-share-weibo" target="_blank" title="微博"></a>',
  '<span title="Share to"></span>'
  ].join('');
  $this.append(html);

  $('.hoverqrcode').hide();

  var myWidth = 0;
  function updatehoverqrcode(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
    var qrsize = myWidth > 1024 ? 200:100;
    var options = {render: 'image', size: qrsize, fill: '#2ca6cb', text: url, radius: 0.5, quiet: 1};
    var p = $('.article-share-qrcode').position();
    $('.hoverqrcode').empty().css('width', qrsize).css('height', qrsize)
                          .css('left', p.left-qrsize/2+20).css('top', p.top-qrsize-10)
                          .qrcode(options);
  };
  $(window).resize(function(){
    $('.hoverqrcode').hide();
  });
  $('.article-share-qrcode').click(function(){
    updatehoverqrcode();
    $('.hoverqrcode').toggle();
  });
  $('.article-share-qrcode').hover(function(){}, function(){
      $('.hoverqrcode').hide();
  });
});   
</script>



<script type="text/javascript">
  var duoshuoQuery = {short_name:"yoferzhang"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = '//yoferzhang.github.io/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
    || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
</script> 







<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



<!-- Analytics Begin -->

<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-83435219-1', 'yoferzhang.com');  
ga('send', 'pageview');
</script>



<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?a6dda28cb6f26de955e11a3716d6ce9b";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>



<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="返回顶部"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
</html>
