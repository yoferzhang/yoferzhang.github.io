<!DOCTYPE html>












  


<html class="theme-next pisces use-motion" lang="zh-CN">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2"/>
<meta name="theme-color" content="#222">



  
  
  <link rel="stylesheet" href="/lib/needsharebutton/needsharebutton.css">










<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=6.4.0" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.jpg?v=6.4.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.jpg?v=6.4.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.jpg?v=6.4.0">


  <link rel="mask-icon" href="/images/logo1.svg?v=6.4.0" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '6.4.0',
    sidebar: {"position":"left","width":300,"display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="版权声明：本文为博主原创，如需转载请注明出处。

1. 多线程概念进程

正在进行中的程序被称为进程，负责程序运行的内存分配
每一个进程都有自己独立的虚拟内存空间

线程

线程是进程中一个独立的执行路径(控制单元)
一个进程中至少包含一条线程，即主线程
可以将耗时的执行路径(如：网络请求)放在其他线程中执行

创建线程的目的就是为了开启一条新的执行路径，运行指定的代码，与主线程中的代码实现同时">
<meta property="og:type" content="article">
<meta property="og:title" content="【iOS】iOS并发编程对比总结,NSThread,NSOperation,GCD">
<meta property="og:url" content="http://yoferzhang.com/post/20160830ConcurrencyProgrammingGuide/index.html">
<meta property="og:site_name" content="YoferZhang 的博客">
<meta property="og:description" content="版权声明：本文为博主原创，如需转载请注明出处。

1. 多线程概念进程

正在进行中的程序被称为进程，负责程序运行的内存分配
每一个进程都有自己独立的虚拟内存空间

线程

线程是进程中一个独立的执行路径(控制单元)
一个进程中至少包含一条线程，即主线程
可以将耗时的执行路径(如：网络请求)放在其他线程中执行

创建线程的目的就是为了开启一条新的执行路径，运行指定的代码，与主线程中的代码实现同时">
<meta property="og:updated_time" content="2017-02-09T05:24:51.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="【iOS】iOS并发编程对比总结,NSThread,NSOperation,GCD">
<meta name="twitter:description" content="版权声明：本文为博主原创，如需转载请注明出处。

1. 多线程概念进程

正在进行中的程序被称为进程，负责程序运行的内存分配
每一个进程都有自己独立的虚拟内存空间

线程

线程是进程中一个独立的执行路径(控制单元)
一个进程中至少包含一条线程，即主线程
可以将耗时的执行路径(如：网络请求)放在其他线程中执行

创建线程的目的就是为了开启一条新的执行路径，运行指定的代码，与主线程中的代码实现同时">



  <link rel="alternate" href="/atom.xml" title="YoferZhang 的博客" type="application/atom+xml" />




  <link rel="canonical" href="http://yoferzhang.com/post/20160830ConcurrencyProgrammingGuide/"/>



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>【iOS】iOS并发编程对比总结,NSThread,NSOperation,GCD | YoferZhang 的博客</title>
  




<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83435219-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-83435219-1');
</script>



  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?a6dda28cb6f26de955e11a3716d6ce9b";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript><!-- hexo-inject:begin --><!-- hexo-inject:end -->

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">YoferZhang 的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">数学出身，功底扎实，热爱编程，虽然编程起步晚，但是冲劲十足。</p>
      
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-索引-|-index">
    <a href="/index/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-home"></i> <br />索引 | Index</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-关于-|-about">
    <a href="/about" rel="section">
      <i class="menu-item-icon fa fa-fw fa-user"></i> <br />关于 | About</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-标签-|-tags">
    <a href="/tags/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />标签 | tags</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-分类-|-categories">
    <a href="/categories/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-th"></i> <br />分类 | categories</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-归档-|-archives">
    <a href="/archives/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />归档 | Archives</a>
  </li>

      
      
    </ul>
  

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoferzhang.com/post/20160830ConcurrencyProgrammingGuide/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yofer Zhang">
      <meta itemprop="description" content="接下来自己能够坚持写博客，记录是一个好习惯">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="YoferZhang 的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">【iOS】iOS并发编程对比总结,NSThread,NSOperation,GCD
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2016-08-30 17:41:03" itemprop="dateCreated datePublished" datetime="2016-08-30T17:41:03+08:00">2016-08-30</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2017-02-09 13:24:51" itemprop="dateModified" datetime="2017-02-09T13:24:51+08:00">2017-02-09</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/iOS/" itemprop="url" rel="index"><span itemprop="name">iOS</span></a></span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/post/20160830ConcurrencyProgrammingGuide/#comments" itemprop="discussionUrl">
                
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="post/20160830ConcurrencyProgrammingGuide/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <blockquote>
<p>版权声明：本文为博主原创，如需转载请注明出处。</p>
</blockquote>
<h2 id="1-多线程概念"><a href="#1-多线程概念" class="headerlink" title="1. 多线程概念"></a>1. 多线程概念</h2><p>进程</p>
<ul>
<li>正在进行中的程序被称为进程，负责程序运行的内存分配</li>
<li>每一个进程都有自己独立的虚拟内存空间</li>
</ul>
<p>线程</p>
<ul>
<li>线程是进程中一个独立的执行路径(控制单元)</li>
<li>一个进程中至少包含一条线程，即主线程</li>
<li>可以将耗时的执行路径(如：网络请求)放在其他线程中执行</li>
</ul>
<p>创建线程的目的就是为了开启一条新的执行路径，运行指定的代码，与主线程中的代码实现同时运行</p>
<center>
![](http://ww2.sinaimg.cn/mw690/a9c4d5f6gw1f7bzfmbtm6j210d09eq7t.jpg)
</center>

<a id="more"></a>
<h3 id="1-1-多任务系统调度示意图"><a href="#1-1-多任务系统调度示意图" class="headerlink" title="1.1 多任务系统调度示意图"></a>1.1 多任务系统调度示意图</h3><center>
![](http://ww1.sinaimg.cn/mw690/a9c4d5f6gw1f7c0wop4esj20ro0efwhy.jpg)
</center>

<p>说明：每个应用程序由操作系统分配的短暂的时间片(Timeslice)轮流使用CPU，由于CPU对每个时间片的处理速度非常快，因此，用户看来好像这些任务在同时执行的</p>
<p>并发：指两个或多个任务在同一时间间隔内发生，但是，在任意一个时刻点上，CPU只会处理一个任务</p>
<h3 id="1-2-优势、弊端以及误区"><a href="#1-2-优势、弊端以及误区" class="headerlink" title="1.2 优势、弊端以及误区"></a>1.2 优势、弊端以及误区</h3><p>优势</p>
<ul>
<li>充分发挥多核处理器优势，将不同线程任务分配给不同的处理器，真正进入“并行运算”状态</li>
<li>将耗时的任务分配到其他线程执行，由主线程负责统一更新界面会使应用程序更加流畅，用户体验更好</li>
<li>当硬件处理器的数量增加，程序会运行更快，而程序无需做任何调整</li>
</ul>
<p>弊端</p>
<ul>
<li>新建线程会消耗内存空间和CPU时间，线程太多会降低系统的运行性能</li>
</ul>
<p>误区</p>
<ul>
<li>多线程技术是为了并发执行多项任务，不会提高单个算法本身的执行效率</li>
</ul>
<h3 id="1-3-iOS的三种多线程技术"><a href="#1-3-iOS的三种多线程技术" class="headerlink" title="1.3 iOS的三种多线程技术"></a>1.3 iOS的三种多线程技术</h3><p>NSThread</p>
<ul>
<li>使用NSThread对象建立一个线程非常方便</li>
<li>但是！要使用NSThread管理多个线程非常困难，不推荐使用</li>
<li>技巧！使用[NSThread currentThread]跟踪任务所在线程，适用于这三种技术</li>
</ul>
<p>NSOperation/NSOperationQueue</p>
<ul>
<li>是使用GCD实现的一套Objective-C的API</li>
<li>是面向对象的线程技术</li>
<li>提供了一些在GCD中不容易实现的特性，如：限制最大并发数量、操作之间的依赖关系</li>
</ul>
<p>GCD —— Grand Central Dispatch </p>
<ul>
<li>是基于C语言的底层API</li>
<li>用Block定义任务，使用起来非常灵活便捷</li>
<li>提供了更多的控制能力以及操作队列中所不能使用的底层函数</li>
</ul>
<p>提示：iOS的开发者，需要了解三种多线程技术的基本使用，因为在实际开发中会根据实际情况选择不同的多线程技术</p>
<h2 id="2-GCD-Grand-Central-Dispatch"><a href="#2-GCD-Grand-Central-Dispatch" class="headerlink" title="2 GCD - Grand Central Dispatch"></a>2 GCD - Grand Central Dispatch</h2><h3 id="2-1-GCD基本思想"><a href="#2-1-GCD基本思想" class="headerlink" title="2.1 GCD基本思想"></a>2.1 GCD基本思想</h3><p>GCD的基本思想是就将操作s放在队列s中去执行</p>
<ul>
<li>操作使用Blocks定义</li>
<li>队列负责调度任务执行所在的线程以及具体的执行时间</li>
<li>队列的特点是先进先出(FIFO)的，新添加至对列的操作都会排在队尾</li>
</ul>
<p>提示</p>
<ul>
<li>GCD的函数都是以dispatch(分派、调度)开头的</li>
</ul>
<p>队列<code>dispatch_queue_t</code></p>
<ul>
<li>串行队列，队列中的任务只会顺序执行</li>
<li>并行队列，队列中的任务通常会并发执行</li>
</ul>
<p>操作</p>
<ul>
<li><code>dispatch_async</code> 异步操作，会并发执行，无法确定任务的执行顺序</li>
<li><code>dispatch_sync</code> 同步操作，会依次顺序执行，能够决定任务的执行顺序</li>
</ul>
<p>注：</p>
<ul>
<li>队列不是线程？也不表示对应的CPU</li>
<li>队列就是负责调度的!谁空闲，就把任务给谁！</li>
<li>多线程技术的目的，就是为了在一个CPU上实现快速切换！</li>
</ul>
<h3 id="2-2-串行队列"><a href="#2-2-串行队列" class="headerlink" title="2.2 串行队列"></a>2.2 串行队列</h3><center>
![](http://ww2.sinaimg.cn/mw690/a9c4d5f6gw1f7c1snqhqcj223817mb29.jpg)
</center>

<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#pragma mark - 串行（一个接一个，排队跑步，保持队形）队列</span></span><br><span class="line">- (<span class="keyword">void</span>)gcdDemo1</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 将操作放在队列中</span></span><br><span class="line">    <span class="comment">// 在C语言函数中，定义类型，绝大多数的结尾是_t或者ref</span></span><br><span class="line">    <span class="comment">// 使用串行队列，的异步任务非常非常非常有用！新建子线程是有开销的，不能无休止新建线程</span></span><br><span class="line">    <span class="comment">// 即可以保证效率（新建一个子线程），用能够实现并发</span></span><br><span class="line">    <span class="comment">// 应用案例：</span></span><br><span class="line">    <span class="comment">// 1&gt; 从网络上上下载图片</span></span><br><span class="line">    <span class="comment">// 2&gt; 滤镜（高光，红眼...）</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> q = dispatch_queue_create(<span class="string">"com.yoferzhang.gcddemo"</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 非ARC开发时，千万别忘记release</span></span><br><span class="line"><span class="comment">//    dispatch_release(q);</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 串行行队列的同步任务，同样会在主线程上运行</span></span><br><span class="line">    <span class="comment">// 提示：在开发中极少用d</span></span><br><span class="line">    <span class="comment">// 面试中有可能会问！</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        <span class="comment">// 同步任务顺序执行</span></span><br><span class="line">        <span class="built_in">dispatch_sync</span>(q, ^&#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"%@ %d"</span>, [<span class="built_in">NSThread</span> currentThread], i);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        <span class="comment">// 异步任务，并发执行，但是如果在串行队列中，仍然会依次顺序执行</span></span><br><span class="line">        <span class="built_in">dispatch_async</span>(q, ^&#123;</span><br><span class="line">            <span class="comment">// [NSThread currentThread] 可以在开发中，跟踪当前线程</span></span><br><span class="line">            <span class="comment">// num = 1，表示主线程</span></span><br><span class="line">            <span class="comment">// num = 2，表示第2个子线程。。。</span></span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"%@ %d"</span>, [<span class="built_in">NSThread</span> currentThread], i);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-3-并行队列"><a href="#2-3-并行队列" class="headerlink" title="2.3 并行队列"></a>2.3 并行队列</h3><center>
![](http://ww3.sinaimg.cn/mw690/a9c4d5f6gw1f7c2280muvj223m15ab29.jpg)
</center>

<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#pragma mark - 并行（并排跑，类似于赛跑）</span></span><br><span class="line">- (<span class="keyword">void</span>)gcdDemo2</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 特点：没有队形，执行顺序程序员不能控制！</span></span><br><span class="line">    <span class="comment">// 应用场景：并发执行任务，没有先后顺序关系</span></span><br><span class="line">    <span class="comment">// 并行队列容易出错！并行队列不能控制新建线程的数量！</span></span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> q = dispatch_queue_create(<span class="string">"com.yoferzhang.gcd2"</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    </span><br><span class="line"><span class="comment">//    for (int i = 0; i &lt; 10; ++i) &#123;</span></span><br><span class="line"><span class="comment">//        // 异步任务</span></span><br><span class="line"><span class="comment">//        dispatch_async(q, ^&#123;</span></span><br><span class="line"><span class="comment">//            // [NSThread currentThread] 可以在开发中，跟踪当前线程</span></span><br><span class="line"><span class="comment">//            // num = 1，表示主线程</span></span><br><span class="line"><span class="comment">//            // num = 2，表示第2个子线程。。。</span></span><br><span class="line"><span class="comment">//            NSLog(@"%@ %d", [NSThread currentThread], i);</span></span><br><span class="line"><span class="comment">//        &#125;);</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        <span class="comment">// 同步任务顺序执行</span></span><br><span class="line">        <span class="built_in">dispatch_sync</span>(q, ^&#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"%@ %d"</span>, [<span class="built_in">NSThread</span> currentThread], i);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-4-全局队列"><a href="#2-4-全局队列" class="headerlink" title="2.4 全局队列"></a>2.4 全局队列</h3><center>
![](http://ww2.sinaimg.cn/mw690/a9c4d5f6gw1f7c242thitj220614mb29.jpg)
</center>

<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#pragma mark - 全局队列（苹果为了方便多线程的设计，提供一个全局队列，供所有的APP共同使用）</span></span><br><span class="line">- (<span class="keyword">void</span>)gcdDemo3</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 全局队列与并行队列的区别</span></span><br><span class="line">    <span class="comment">// 1&gt; 不需要创建，直接GET就能用</span></span><br><span class="line">    <span class="comment">// 2&gt; 两个队列的执行效果相同</span></span><br><span class="line">    <span class="comment">// 3&gt; 全局队列没有名称，调试时，无法确认准确队列</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 记住：在开发中永远用DISPATCH_QUEUE_PRIORITY_DEFAULT</span></span><br><span class="line">    <span class="comment">// 多线程的优先级反转！低优先级的线程阻塞了高优先级的线程！</span></span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> q =dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        <span class="comment">// 同步任务顺序执行</span></span><br><span class="line">        <span class="built_in">dispatch_sync</span>(q, ^&#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"%@ %d"</span>, [<span class="built_in">NSThread</span> currentThread], i);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        <span class="comment">// 异步任务，并发执行，但是如果在穿行队列中，仍然会依次顺序执行</span></span><br><span class="line">        <span class="built_in">dispatch_async</span>(q, ^&#123;</span><br><span class="line">            <span class="comment">// [NSThread currentThread] 可以在开发中，跟踪当前线程</span></span><br><span class="line">            <span class="comment">// num = 1，表示主线程</span></span><br><span class="line">            <span class="comment">// num = 2，表示第2个子线程。。。</span></span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"%@ %d"</span>, [<span class="built_in">NSThread</span> currentThread], i);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-5-主队列"><a href="#2-5-主队列" class="headerlink" title="2.5 主队列"></a>2.5 主队列</h3><center>
![](http://ww2.sinaimg.cn/mw690/a9c4d5f6gw1f7c26453v8j2210188hdt.jpg)
</center>

<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#pragma mark - 主(线程)队列，保证操作在主线程上执行</span></span><br><span class="line">- (<span class="keyword">void</span>)gcdDemo4</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 每一个应用程序都只有一个主线程</span></span><br><span class="line">    <span class="comment">// 为什么需要在主线程上工作呢？</span></span><br><span class="line">    <span class="comment">// 在iOS开发中，所有UI的更新工作，都必须在主线程上执行！</span></span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> q = dispatch_get_main_queue();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 主线程是由工作的，而且除非将程序杀掉，否则主线程的工作永远不会结束！</span></span><br><span class="line">    <span class="comment">// 阻塞了！！！</span></span><br><span class="line">    <span class="built_in">dispatch_sync</span>(q, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"come here baby!"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 异步任务，在主线程上运行，同时是保持队形的</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        <span class="built_in">dispatch_async</span>(q, ^&#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"%@ - %d"</span>, [<span class="built_in">NSThread</span> currentThread], i);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-6-不同队列中嵌套dispatch-sync的结果"><a href="#2-6-不同队列中嵌套dispatch-sync的结果" class="headerlink" title="2.6 不同队列中嵌套dispatch_sync的结果"></a>2.6 不同队列中嵌套dispatch_sync的结果</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全局队列，都在主线程上执行，不会死锁</span></span><br><span class="line"><span class="built_in">dispatch_queue_t</span> q = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// 并行队列，都在主线程上执行，不会死锁</span></span><br><span class="line"><span class="built_in">dispatch_queue_t</span> q = dispatch_queue_create(<span class="string">"com.yoferzhang.gcddemo"</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line"><span class="comment">// 串行队列，会死锁，但是会执行嵌套同步操作之前的代码</span></span><br><span class="line"><span class="built_in">dispatch_queue_t</span> q = dispatch_queue_create(<span class="string">"com.yoferzhang.gcddemo"</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line"><span class="comment">// 直接死锁</span></span><br><span class="line"><span class="built_in">dispatch_queue_t</span> q = dispatch_get_main_queue();</span><br><span class="line"></span><br><span class="line"><span class="built_in">dispatch_sync</span>(q, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"同步任务 %@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    <span class="built_in">dispatch_sync</span>(q, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"同步任务 %@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="2-7-dispatch-sync的应用场景"><a href="#2-7-dispatch-sync的应用场景" class="headerlink" title="2.7 dispatch_sync的应用场景"></a>2.7 dispatch_sync的应用场景</h3><ul>
<li>阻塞并行队列的执行，要求某一操作执行后再进行后续操作，如用户登录</li>
<li>确保块代码之外的局部变量确实被修改</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> q = dispatch_queue_create(<span class="string">"com.yoferzhang.gcddemo"</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">__block <span class="built_in">BOOL</span> logon = <span class="literal">NO</span>;</span><br><span class="line"><span class="built_in">dispatch_sync</span>(q, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"模拟耗时操作 %@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">      [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">2.0</span>f];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"模拟耗时完成 %@"</span>, [<span class="built_in">NSThread</span> currentThread]); </span><br><span class="line">    logon = <span class="literal">YES</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">dispatch_async</span>(q, ^&#123;</span><br><span class="line">       <span class="built_in">NSLog</span>(<span class="string">@"登录完成的处理 %@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">2.0</span>f];</span><br><span class="line"></span><br><span class="line">通常在多线程调试中用于模拟耗时操作</span><br><span class="line">在发布的应用程序中，不要使用此方法！</span><br></pre></td></tr></table></figure>
<h3 id="2-8-GCD——大中央调度"><a href="#2-8-GCD——大中央调度" class="headerlink" title="2.8 GCD——大中央调度"></a>2.8 GCD——大中央调度</h3><ul>
<li>串行队列，同步任务，不需要新建线程</li>
<li><p>串行队列，异步任务，需要一个子线程，线程的创建和回收不需要程序员参与！“是最安全的一个选择”串行队列只能创建！</p>
</li>
<li><p>并行队列，同步任务，不需要创建线程</p>
</li>
<li>并行队列，异步任务，有多少个任务，就开N个线程执行，</li>
</ul>
<p>无论什么队列和什么任务，线程的创建和回收不需要程序员参与。<br>线程的创建回收工作是由队列负责的</p>
<p>“并发”编程，为了让程序员从负责的线程控制中解脱出来！只需要面对队列和任务！</p>
<h3 id="2-9-GCD阶段性小结"><a href="#2-9-GCD阶段性小结" class="headerlink" title="2.9 GCD阶段性小结"></a>2.9 GCD阶段性小结</h3><p>GCD</p>
<ul>
<li>通过GCD，开发者不用再直接跟线程打交道，只需要向队列中添加代码块即可</li>
<li>GCD在后端管理着一个线程池，GCD不仅决定着代码块将在哪个线程被执行，它还根据可用的系统资源对这些线程进行管理。从而让开发者从线程管理的工作中解放出来，通过集中的管理线程，缓解大量线程被创建的问题</li>
<li>使用GCD，开发者可以将工作考虑为一个队列，而不是一堆线程，这种并行的抽象模型更容易掌握和使用</li>
</ul>
<p>GCD的队列</p>
<ul>
<li>GCD公开有5个不同的队列：运行在主线程中的主队列，3 个不同优先级的后台队列，以及一个优先级更低的后台队列（用于 I/O）</li>
<li>自定义队列：串行和并行队列。自定义队列非常强大，建议在开发中使用。在自定义队列中被调度的所有Block最终都将被放入到系统的全局队列中和线程池中</li>
<li>提示：不建议使用不同优先级的队列，因为如果设计不当，可能会出现优先级反转，即低优先级的操作阻塞高优先级的操作</li>
</ul>
<h3 id="2-10-GCD队列示意图"><a href="#2-10-GCD队列示意图" class="headerlink" title="2.10 GCD队列示意图"></a>2.10 GCD队列示意图</h3><center>
![](http://ww2.sinaimg.cn/mw690/a9c4d5f6gw1f7c2dj8c6cj21110lbjvb.jpg)
</center>

<h2 id="3-NSOperation"><a href="#3-NSOperation" class="headerlink" title="3 NSOperation"></a>3 NSOperation</h2><h3 id="3-1-NSOperation-amp-NSOperationQueue"><a href="#3-1-NSOperation-amp-NSOperationQueue" class="headerlink" title="3.1 NSOperation &amp; NSOperationQueue"></a>3.1 NSOperation &amp; NSOperationQueue</h3><p>简介</p>
<ul>
<li>NSOperationQueue(操作队列)是由GCD提供的队列模型的Cocoa抽象，是一套Objective-C的API</li>
<li>GCD提供了更加底层的控制，而操作队列则在GCD之上实现了一些方便的功能，这些功能对于开发者而言通常是最好最安全的选择<br>队列及操作</li>
</ul>
<p>NSOperationQueue有两种不同类型的队列：主队列和自定义队列</p>
<p>主队列运行在主线程上</p>
<p>自定义队列在后台执行</p>
<p>队列处理的任务是NSOperation的子类</p>
<ul>
<li>NSInvocationOperation</li>
<li>NSBlockOperation</li>
</ul>
<h3 id="3-2-NSOperation的基本使用步骤"><a href="#3-2-NSOperation的基本使用步骤" class="headerlink" title="3.2 NSOperation的基本使用步骤"></a>3.2 NSOperation的基本使用步骤</h3><p>基本使用步骤</p>
<ul>
<li>定义操作队列</li>
<li>定义操作</li>
<li>将操作添加到队列</li>
</ul>
<p>提示：一旦将操作添加到队列，操作就会立即被调度执行</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#pragma mark NSBlockOperation</span></span><br><span class="line">- (<span class="keyword">void</span>)demoOp1</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//    NSBlockOperation *block = [NSBlockOperation blockOperationWithBlock:^&#123;</span></span><br><span class="line"><span class="comment">//        NSLog(@"%@", [NSThread currentThread]);</span></span><br><span class="line"><span class="comment">//    &#125;];</span></span><br><span class="line"><span class="comment">//    </span></span><br><span class="line">    <span class="comment">// 所有的自定义队列，都是在子线程中运行</span></span><br><span class="line"><span class="comment">//    [self.myQueue addOperation:block];</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 新建线程是有开销的</span></span><br><span class="line">    <span class="comment">// 在设定同时并发的最大线程数时，如果前一个线程工作完成，但是还没有销毁，会新建线程</span></span><br><span class="line">    <span class="comment">// 应用场景：网络开发中，下载工作！（线程开销：CPU,MEM）电量！</span></span><br><span class="line">    <span class="comment">// 如果是3G，开3个子线程</span></span><br><span class="line">    <span class="comment">// 如果是WIFI，开6个子线程</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        [<span class="keyword">self</span>.myQueue addOperationWithBlock:^&#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"%@ %d"</span>, [<span class="built_in">NSThread</span> currentThread], i);</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在主线程中执行</span></span><br><span class="line"><span class="comment">//    [[NSOperationQueue mainQueue] addOperationWithBlock:^&#123;</span></span><br><span class="line"><span class="comment">//        NSLog(@"%@", [NSThread currentThread]);</span></span><br><span class="line"><span class="comment">//    &#125;];</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-3-NSInvocationOperation-调度操作"><a href="#3-3-NSInvocationOperation-调度操作" class="headerlink" title="3.3 NSInvocationOperation(调度操作)"></a>3.3 NSInvocationOperation(调度操作)</h3><p>定义队列</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span>.myQueue = [[<span class="built_in">NSOperationQueue</span> alloc] init];</span><br></pre></td></tr></table></figure>
<p>操作调用的方法</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)operationAction:(<span class="keyword">id</span>)obj</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@ - obj : %@"</span>, [<span class="built_in">NSThread</span> currentThread], obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义操作并添加到队列</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSInvocationOperation</span> *op = [[<span class="built_in">NSInvocationOperation</span> alloc] initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(operationAction:) object:@(i)];</span><br><span class="line">[<span class="keyword">self</span>.myQueue addOperation:op];</span><br></pre></td></tr></table></figure>
<p>小结：需要准备一个被调度的方法，并且能够接收一个参数</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#pragma mark NSInvocationOP</span></span><br><span class="line">- (<span class="keyword">void</span>)demoOp2</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 需要定义一个方法，能够接收一个参数</span></span><br><span class="line">    <span class="comment">// 是用起来不够灵活</span></span><br><span class="line">    <span class="built_in">NSInvocationOperation</span> *op = [[<span class="built_in">NSInvocationOperation</span> alloc] initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(demoOp:) object:<span class="string">@"hello op"</span>];</span><br><span class="line">    </span><br><span class="line"><span class="comment">//    [self.myQueue addOperation:op];</span></span><br><span class="line">    </span><br><span class="line">    [[<span class="built_in">NSOperationQueue</span> mainQueue] addOperation:op];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-4-设置操作的依赖关系"><a href="#3-4-设置操作的依赖关系" class="headerlink" title="3.4 设置操作的依赖关系"></a>3.4 设置操作的依赖关系</h3><p>提示：利用addDependency可以指定操作之间的彼此依赖关系(执行先后顺序)</p>
<p>注意：不要出现循环依赖！</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#pragma mark - NSOperation方法</span></span><br><span class="line"><span class="meta">#pragma mark 设置任务的执行顺序</span></span><br><span class="line">- (<span class="keyword">void</span>)demoOp3</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSBlockOperation</span> *op1 = [<span class="built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"下载图片 %@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;];</span><br><span class="line">    <span class="built_in">NSBlockOperation</span> *op2 = [<span class="built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"修饰图片 %@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;];</span><br><span class="line">    <span class="built_in">NSBlockOperation</span> *op3 = [<span class="built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"保存图片 %@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;];</span><br><span class="line">    <span class="built_in">NSBlockOperation</span> *op4 = [<span class="built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"更新UI %@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设定执行顺序, Dependency依赖，可能会开多个，但不会太多</span></span><br><span class="line">    <span class="comment">// 依赖关系是可以跨队列的！</span></span><br><span class="line">    [op2 addDependency:op1];</span><br><span class="line">    [op3 addDependency:op2];</span><br><span class="line">    [op4 addDependency:op3];</span><br><span class="line">    <span class="comment">// GCD是串行队列，异步任务，只会开一个线程</span></span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">self</span>.myQueue addOperation:op1];</span><br><span class="line">    [<span class="keyword">self</span>.myQueue addOperation:op2];</span><br><span class="line">    [<span class="keyword">self</span>.myQueue addOperation:op3];</span><br><span class="line">    <span class="comment">// 所有UI的更新需要在主线程上进行</span></span><br><span class="line">    [[<span class="built_in">NSOperationQueue</span> mainQueue] addOperation:op4];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-5-设置同时并发的线程数量"><a href="#3-5-设置同时并发的线程数量" class="headerlink" title="3.5 设置同时并发的线程数量"></a>3.5 设置同时并发的线程数量</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">self</span>.myQueue setMaxConcurrentOperationCount:<span class="number">2</span>];</span><br><span class="line"><span class="comment">// 设置同时并发的线程数量能够有效地降低CPU和内存的开销</span></span><br><span class="line"><span class="comment">// 这一功能用GCD不容易实现</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">    <span class="built_in">NSBlockOperation</span> *op = [<span class="built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class="line">        [<span class="keyword">self</span> operationAction:@(i)];</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">self</span>.myQueue addOperation:op];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-6-NSOperation小结"><a href="#3-6-NSOperation小结" class="headerlink" title="3.6 NSOperation小结"></a>3.6 NSOperation小结</h3><p>从本质上来看，操作队列的性能会比GCD略低，不过，大多数情况下这点负面影响可以忽略不计，操作队列是并发编程的首选工具</p>
<p>AFN，底层用GCD开发，开发的接口是NSOperation的。</p>
<h2 id="4-Run-Loop"><a href="#4-Run-Loop" class="headerlink" title="4 Run Loop"></a>4 Run Loop</h2><ul>
<li>Run Loop提供了一种异步执行代码的机制，不能并行执行任务</li>
<li>在主队列中，Main Run Loop直接配合任务的执行，负责处理UI事件、计时器，以及其它内核相关事件</li>
<li>Run Loop的主要目的是保证程序执行的线程不会被系统终止</li>
</ul>
<p>Run Loop的工作特点</p>
<ul>
<li>当有事件发生时，Run Loop会根据具体的事件类型通知应用程序做出响应</li>
<li>当没有事件发生时，Run Loop会进入休眠状态，从而达到省电的目的</li>
<li>当事件再次发生时，Run Loop会被重新唤醒，处理事件</li>
<li>主线程和其他线程中的Run Loop</li>
</ul>
<p>iOS程序的主线程默认已经配置好了Run Loop</p>
<p>其他线程默认情况下没有设置Run Loop</p>
<p>一般在开发中很少会主动创建RunLoop，而通常会把事件添加到RunLoop中</p>
<h3 id="4-1-RunLoop示意图"><a href="#4-1-RunLoop示意图" class="headerlink" title="4.1 RunLoop示意图"></a>4.1 RunLoop示意图</h3><center>
![](http://ww4.sinaimg.cn/mw690/a9c4d5f6gw1f7c2mzokvvj21sq15u7wh.jpg)
</center>

<h3 id="4-2-UIApplication中的Run-Loop"><a href="#4-2-UIApplication中的Run-Loop" class="headerlink" title="4.2 UIApplication中的Run Loop"></a>4.2 UIApplication中的Run Loop</h3><center>
![](http://ww4.sinaimg.cn/mw690/a9c4d5f6gw1f7c2oiph4xj21110lb11g.jpg)
</center>

<h3 id="4-3-多线程中的循环引用"><a href="#4-3-多线程中的循环引用" class="headerlink" title="4.3 多线程中的循环引用"></a>4.3 多线程中的循环引用</h3><p>如果self对象持有操作对象的引用，同时操作对象当中又直接访问了self时，才会造成循环引用</p>
<p>单纯在操作对象中使用self不会造成循环引用</p>
<p>注意：此时不能使用(weakSelf)</p>
<h2 id="5-资源共享"><a href="#5-资源共享" class="headerlink" title="5 资源共享"></a>5 资源共享</h2><h3 id="5-1-多线程中的资源共享"><a href="#5-1-多线程中的资源共享" class="headerlink" title="5.1 多线程中的资源共享"></a>5.1 多线程中的资源共享</h3><p>并发编程中许多问题的根源就是在多线程中访问共享资源。资源可以是一个属性、一个对象、网络设备或者一个文件等</p>
<p>在多线程中任何一个共享的资源都可能是一个潜在的冲突点，必须精心设计以防止这种冲突的发生</p>
<h3 id="5-2-资源共享示例"><a href="#5-2-资源共享示例" class="headerlink" title="5.2 资源共享示例"></a>5.2 资源共享示例</h3><center>
![](http://ww1.sinaimg.cn/mw690/a9c4d5f6gw1f7c2r17clmj20x80ihmz8.jpg)
</center>

<h3 id="5-3-互斥锁-synchronized"><a href="#5-3-互斥锁-synchronized" class="headerlink" title="5.3 互斥锁(@synchronized)"></a>5.3 互斥锁(@synchronized)</h3><center>
![](http://ww2.sinaimg.cn/mw690/a9c4d5f6gw1f7c2rpwk1fj21040m6ju3.jpg)
</center>

<h3 id="5-4-共享资源小结"><a href="#5-4-共享资源小结" class="headerlink" title="5.4 共享资源小结"></a>5.4 共享资源小结</h3><ul>
<li>为了保证性能，atomic仅针对属性的setter方法做了保护</li>
<li>而争抢共享资源时，如果涉及到属性的getter方法，可以使用互斥锁@synchronized可以保证属性在多个线程之间的读写都是安全的</li>
<li>无论是atomic还是@synchronized，使用的代价都是高昂的</li>
</ul>
<p>建议：多线程是并发执行多个任务提高效率的，如果可能，应该在线程中避免争抢共享资源</p>
<p>正是出于性能的考虑，UIKit中的绝大多数的类都不是线程安全的，因此，苹果公司要求：更新UI相关的操作，应该在主线程中执行</p>
<p>取舍！</p>
<h2 id="6单例"><a href="#6单例" class="headerlink" title="6单例"></a>6单例</h2><ul>
<li>单例模式是一种常用的软件设计模式</li>
<li>通过单例模式可以保证系统中一个类只有一个实例而且该实例易于外界访问，从而方便对实例个数的控制并节约系统资源</li>
<li>如果希望系统中某个类的对象只能存在一个，单例模式是最好的解决方案</li>
</ul>
<p>iOS中最常见的单例就是UIApplication </p>
<p>应用场景：</p>
<ul>
<li>音频播放，背景音乐！</li>
<li>硬件资源：加速器、[UIScreen mainScreen]</li>
</ul>
<p>sharedXX, mainXXX</p>
<h3 id="6-1-单例的实现步骤"><a href="#6-1-单例的实现步骤" class="headerlink" title="6.1 单例的实现步骤"></a>6.1 单例的实现步骤</h3><p>重写allocWithZone方法</p>
<p>allocWithZone方法是对象分配内存空间时，最终会调用的方法，重写该方法，保证只会分配一个内存空间</p>
<p>建立sharedXXX类方法，便于其他类访问</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">DemoObj</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 共享实例，便于其他类访问</span></span><br><span class="line">+ (instancetype)sharedDemoObj;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"DemoObj.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">DemoObj</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> DemoObj *instance;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> 1. 重写allocWithZone，用dispatch_once实例化一个静态变量</span><br><span class="line"> 2. 写一个+sharedXXX方便其他类调用</span><br><span class="line"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在iOS中，所有对象的内存空间的分配，最终都会调用allocWithZone方法</span></span><br><span class="line"><span class="comment">// 如果要做单例，需要重写此方法</span></span><br><span class="line"><span class="comment">// GCD提供了一个方法，专门用来创建单例的</span></span><br><span class="line">+ (<span class="keyword">id</span>)allocWithZone:(<span class="keyword">struct</span> _<span class="built_in">NSZone</span> *)zone</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> DemoObj *instance;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// dispatch_once是线程安全的，onceToken默认为0</span></span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="comment">// dispatch_once宏可以保证块代码中的指令只被执行一次</span></span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        <span class="comment">// 在多线程环境下，永远只会被执行一次，instance只会被实例化一次</span></span><br><span class="line">        instance = [<span class="keyword">super</span> allocWithZone:zone];</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (instancetype)sharedDemoObj</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 如果有两个线程同时实例化，很有可能创建出两个实例来</span></span><br><span class="line"><span class="comment">//    if (!instance) &#123;</span></span><br><span class="line"><span class="comment">//        // thread 1 0x0000A</span></span><br><span class="line"><span class="comment">//        // thread 2 0x0000B</span></span><br><span class="line"><span class="comment">//        instance = [[self alloc] init];</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//    // 第一个线程返回的指针已经被修改！</span></span><br><span class="line"><span class="comment">//    return instance;</span></span><br><span class="line">    <span class="keyword">return</span> [[<span class="keyword">self</span> alloc] init];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<h3 id="6-2-单例小结"><a href="#6-2-单例小结" class="headerlink" title="6.2 单例小结"></a>6.2 单例小结</h3><p>优点</p>
<ul>
<li>可以阻止其他对象实例化单例对象的副本，从而确保所有对象都访问唯一实例</li>
</ul>
<p>缺点</p>
<ul>
<li>单例对象一旦建立，对象指针是保存在静态区的，单例对象在堆中分配的内存空间，会在应用程序终止后才会被释放</li>
</ul>
<p>提示</p>
<ul>
<li>只有确实需要唯一使用的对象才需要考虑单例模式，不要滥用单例</li>
</ul>
<h2 id="7-NSThread"><a href="#7-NSThread" class="headerlink" title="7 NSThread"></a>7 NSThread</h2><h3 id="7-1-NSObject的多线程方法"><a href="#7-1-NSObject的多线程方法" class="headerlink" title="7.1 NSObject的多线程方法"></a>7.1 NSObject的多线程方法</h3><p>开启后台执行任务的方法</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)performSelectorInBackground:(SEL)aSelector withObject:(<span class="keyword">id</span>)arg</span><br></pre></td></tr></table></figure>
<p>在后台线程中通知主线程执行任务的方法</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)performSelectorOnMainThread:(SEL)aSelector withObject:(<span class="keyword">id</span>)arg waitUntilDone:(<span class="built_in">BOOL</span>)wait</span><br></pre></td></tr></table></figure>
<p>获取线程信息<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="built_in">NSThread</span> currentThread]</span><br></pre></td></tr></table></figure></p>
<p>线程休眠</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">2.0</span>f];</span><br></pre></td></tr></table></figure>
<p>特点</p>
<ul>
<li>使用简单，量级轻</li>
<li>不能控制线程的数量以及执行顺序</li>
</ul>
<h3 id="7-2-NSObject的多线程方法注意事项"><a href="#7-2-NSObject的多线程方法注意事项" class="headerlink" title="7.2 NSObject的多线程方法注意事项"></a>7.2 NSObject的多线程方法注意事项</h3><p>NSObject的多线程方法使用的是NSThread的多线程技术</p>
<p>而NSThread的多线程技术不会自动使用@autoreleasepool</p>
<p>在使用NSObject或NSThread的多线程技术时，如果涉及到对象分配，需要手动添加@autoreleasepool</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"ViewController.h"</span></span></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> 需求分析</span><br><span class="line"> </span><br><span class="line"> 1. UIImageView显示图片</span><br><span class="line"> 2. UIImage模拟从网络上下载</span><br><span class="line"> 3. NSString记录图片路径</span><br><span class="line"> </span><br><span class="line"> 小结</span><br><span class="line"> </span><br><span class="line"> 方法，看起来很简单，</span><br><span class="line"> </span><br><span class="line"> 1&gt; 不能够自动回收线程，如果并发数量多，会建立大量的子线程！</span><br><span class="line"> 2&gt; 使用NSThread的线程，不会自动添加autoreleasepool</span><br><span class="line"> </span><br><span class="line">    意味着，如果在后台线程方法中，</span><br><span class="line"> </span><br><span class="line"> @autoreleasepool &#123;&#125; 自动释放池</span><br><span class="line"> </span><br><span class="line"> 主线程中是有自动释放池的，使用GCD和NSOperation也会自动添加自动释放池</span><br><span class="line"> </span><br><span class="line"> NSThread和NSObject不会，如果在后台线程中创建了autorelease的对象，需要使用自动释放池，否则会出现内存泄漏！</span><br><span class="line"> </span><br><span class="line"> 工作原理：</span><br><span class="line"> </span><br><span class="line"> 1. 当自动释放池被销毁或者“耗尽”时，对池中的所有对象发送release消息，清空自动释放池</span><br><span class="line"> 2. 所有autorelease的对象，在出了作用域之后，会自动添加到【最近一次创建的自动释放池中】自动释放池中</span><br><span class="line"> </span><br><span class="line"> 在ARC中，编译器在编译过程中，会自动根据代码结构，添加retain和release。</span><br><span class="line"> */</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">UIImageView</span> *imageView;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">UIImage</span> *image;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSString</span> *imagePath;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 0. 模拟使用图像路径加载图片</span></span><br><span class="line">- (<span class="keyword">void</span>)setImagePath:(<span class="built_in">NSString</span> *)imagePath</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 1&gt; 模拟下载，延时</span></span><br><span class="line">        [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">1.0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2&gt; 设置图像，苹果底层允许使用performSelectorInBackground方法</span></span><br><span class="line">        <span class="comment">// 在后台线程更新UI，强烈不建议大家这么做！</span></span><br><span class="line">        <span class="comment">// YES会阻塞住线程，直到调用方法完成</span></span><br><span class="line">        <span class="comment">// NO不会阻塞线程，会继续执行</span></span><br><span class="line">        [<span class="keyword">self</span> performSelectorOnMainThread:<span class="keyword">@selector</span>(setImage:) withObject:[<span class="built_in">UIImage</span> imageNamed:imagePath] waitUntilDone:<span class="literal">NO</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 图像</span></span><br><span class="line">- (<span class="keyword">void</span>)setImage:(<span class="built_in">UIImage</span> *)image</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">self</span>.imageView.image = image;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//    [NSThread sleepForTimeInterval:1.0];</span></span><br><span class="line">    <span class="comment">// 根据图片自动调整大小</span></span><br><span class="line">    [<span class="keyword">self</span>.imageView sizeToFit];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 创建imageView</span></span><br><span class="line">- (<span class="built_in">UIImageView</span> *)imageView</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!_imageView) &#123;</span><br><span class="line">        _imageView = [[<span class="built_in">UIImageView</span> alloc] init];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> _imageView;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">self</span>.view addSubview:<span class="keyword">self</span>.imageView];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在后台线程执行这段代码即可</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; ++i) &#123;</span><br><span class="line">        [<span class="keyword">self</span> performSelectorInBackground:<span class="keyword">@selector</span>(setImagePath:) withObject:<span class="string">@"头像1.png"</span>];</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    [self setImagePath: @"头像1.png"];</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)demo</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 提问：代码存在什么问题？如果循环次数非常大，会出现什么问题？应该如何修改？</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 解决办法1：如果i比较大，可以</span></span><br><span class="line">    <span class="comment">// 解决方法2：如果非常大，一次循环都会造成自动释放池被填满</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000000</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">            <span class="comment">// *</span></span><br><span class="line">            <span class="built_in">NSString</span> *str = <span class="string">@"Hello World!"</span>;</span><br><span class="line">            <span class="comment">// new *</span></span><br><span class="line">            str = [str uppercaseString];</span><br><span class="line">            <span class="comment">// new *</span></span><br><span class="line">            str = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@ %d"</span>, str, i];</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, str);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>参考文章：<br><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/Multithreading/Introduction/Introduction.html#//apple_ref/doc/uid/10000057i-CH1-SW1" target="_blank" rel="external">Threading Programming Guide</a><br><a href="https://developer.apple.com/library/ios/documentation/General/Conceptual/ConcurrencyProgrammingGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008091-CH1-SW1" target="_blank" rel="external">Concurrency Programming Guide</a></p>
<p>新博客文章地址：<a href="http://yoferzhang.com/post/20160830ConcurrencyProgrammingGuide/">iOS并发编程对比总结,NSThread,NSOperation,GCD</a><br>CSDN文章地址：<a href="http://blog.csdn.net/zyq522376829/article/details/52373154" target="_blank" rel="external">iOS并发编程对比总结,NSThread,NSOperation,GCD</a></p>
</blockquote>

      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
        <div class="post-widgets">
        

        

        
          
          <div class="social_share">
            
            
               <div id="needsharebutton-postbottom">
                 <span class="btn">
                    <i class="fa fa-share-alt" aria-hidden="true"></i>
                 </span>
               </div>
            
          </div>
        
        </div>
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/post/20160825property/" rel="next" title="【iOS】property属性的weak,strong,copy,assign">
                <i class="fa fa-chevron-left"></i> 【iOS】property属性的weak,strong,copy,assign
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/post/20160831KVO/" rel="prev" title="【iOS】KVO编程指南,Key-Value Observing Programming Guide翻译">
                【iOS】KVO编程指南,Key-Value Observing Programming Guide翻译 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  
    <div class="comments" id="comments">
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.jpg"
                alt="Yofer Zhang" />
            
              <p class="site-author-name" itemprop="name">Yofer Zhang</p>
              <p class="site-description motion-element" itemprop="description">接下来自己能够坚持写博客，记录是一个好习惯</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives">
                
                    <span class="site-state-item-count">108</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">7</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">115</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  <a href="https://github.com/yoferzhang" target="_blank" title="GitHub"><i class="fa fa-fw fa-github"></i>GitHub</a>
                  
                </span>
              
                <span class="links-of-author-item">
                  <a href="mailto:yoferzhang@gmail.com" target="_blank" title="E-Mail"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  
                </span>
              
                <span class="links-of-author-item">
                  <a href="https://plus.google.com/yoferzhang" target="_blank" title="Google"><i class="fa fa-fw fa-google"></i>Google</a>
                  
                </span>
              
                <span class="links-of-author-item">
                  <a href="https://stackoverflow.com/yoferzhang" target="_blank" title="StackOverflow"><i class="fa fa-fw fa-stack-overflow"></i>StackOverflow</a>
                  
                </span>
              
                <span class="links-of-author-item">
                  <a href="https://instagram.com/yoferzhang" target="_blank" title="Instagram"><i class="fa fa-fw fa-instagram"></i>Instagram</a>
                  
                </span>
              
            </div>
          

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-block">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                Links
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="http://ww3.sinaimg.cn/large/a9c4d5f6jw1f2cbilh1uyj2076076t97.jpg" title="WeChat" target="_blank">WeChat</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://cn.linkedin.com/in/耀琦-张-771388117" title="LinkedIn" target="_blank">LinkedIn</a>
                  </li>
                
              </ul>
            </div>
          

          
            
          
          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-多线程概念"><span class="nav-number">1.</span> <span class="nav-text">1. 多线程概念</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-多任务系统调度示意图"><span class="nav-number">1.1.</span> <span class="nav-text">1.1 多任务系统调度示意图</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-优势、弊端以及误区"><span class="nav-number">1.2.</span> <span class="nav-text">1.2 优势、弊端以及误区</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-iOS的三种多线程技术"><span class="nav-number">1.3.</span> <span class="nav-text">1.3 iOS的三种多线程技术</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-GCD-Grand-Central-Dispatch"><span class="nav-number">2.</span> <span class="nav-text">2 GCD - Grand Central Dispatch</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-GCD基本思想"><span class="nav-number">2.1.</span> <span class="nav-text">2.1 GCD基本思想</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-串行队列"><span class="nav-number">2.2.</span> <span class="nav-text">2.2 串行队列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-并行队列"><span class="nav-number">2.3.</span> <span class="nav-text">2.3 并行队列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-全局队列"><span class="nav-number">2.4.</span> <span class="nav-text">2.4 全局队列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-5-主队列"><span class="nav-number">2.5.</span> <span class="nav-text">2.5 主队列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-6-不同队列中嵌套dispatch-sync的结果"><span class="nav-number">2.6.</span> <span class="nav-text">2.6 不同队列中嵌套dispatch_sync的结果</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-7-dispatch-sync的应用场景"><span class="nav-number">2.7.</span> <span class="nav-text">2.7 dispatch_sync的应用场景</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-8-GCD——大中央调度"><span class="nav-number">2.8.</span> <span class="nav-text">2.8 GCD——大中央调度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-9-GCD阶段性小结"><span class="nav-number">2.9.</span> <span class="nav-text">2.9 GCD阶段性小结</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-10-GCD队列示意图"><span class="nav-number">2.10.</span> <span class="nav-text">2.10 GCD队列示意图</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-NSOperation"><span class="nav-number">3.</span> <span class="nav-text">3 NSOperation</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-NSOperation-amp-NSOperationQueue"><span class="nav-number">3.1.</span> <span class="nav-text">3.1 NSOperation & NSOperationQueue</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-NSOperation的基本使用步骤"><span class="nav-number">3.2.</span> <span class="nav-text">3.2 NSOperation的基本使用步骤</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-NSInvocationOperation-调度操作"><span class="nav-number">3.3.</span> <span class="nav-text">3.3 NSInvocationOperation(调度操作)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-设置操作的依赖关系"><span class="nav-number">3.4.</span> <span class="nav-text">3.4 设置操作的依赖关系</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-设置同时并发的线程数量"><span class="nav-number">3.5.</span> <span class="nav-text">3.5 设置同时并发的线程数量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-6-NSOperation小结"><span class="nav-number">3.6.</span> <span class="nav-text">3.6 NSOperation小结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-Run-Loop"><span class="nav-number">4.</span> <span class="nav-text">4 Run Loop</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-RunLoop示意图"><span class="nav-number">4.1.</span> <span class="nav-text">4.1 RunLoop示意图</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-UIApplication中的Run-Loop"><span class="nav-number">4.2.</span> <span class="nav-text">4.2 UIApplication中的Run Loop</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-多线程中的循环引用"><span class="nav-number">4.3.</span> <span class="nav-text">4.3 多线程中的循环引用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-资源共享"><span class="nav-number">5.</span> <span class="nav-text">5 资源共享</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-多线程中的资源共享"><span class="nav-number">5.1.</span> <span class="nav-text">5.1 多线程中的资源共享</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-资源共享示例"><span class="nav-number">5.2.</span> <span class="nav-text">5.2 资源共享示例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-3-互斥锁-synchronized"><span class="nav-number">5.3.</span> <span class="nav-text">5.3 互斥锁(@synchronized)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-4-共享资源小结"><span class="nav-number">5.4.</span> <span class="nav-text">5.4 共享资源小结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6单例"><span class="nav-number">6.</span> <span class="nav-text">6单例</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-1-单例的实现步骤"><span class="nav-number">6.1.</span> <span class="nav-text">6.1 单例的实现步骤</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2-单例小结"><span class="nav-number">6.2.</span> <span class="nav-text">6.2 单例小结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-NSThread"><span class="nav-number">7.</span> <span class="nav-text">7 NSThread</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#7-1-NSObject的多线程方法"><span class="nav-number">7.1.</span> <span class="nav-text">7.1 NSObject的多线程方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-2-NSObject的多线程方法注意事项"><span class="nav-number">7.2.</span> <span class="nav-text">7.2 NSObject的多线程方法注意事项</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love" id="animate">
    <i class="fa fa-yoferzhang"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Yofer Zhang</span>

  

  
</div>




  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动 v3.2.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a class="theme-link" target="_blank" href="https://theme-next.org">NexT.Pisces</a> v6.4.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    
	
    

    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.4.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.4.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=6.4.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=6.4.0"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=6.4.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=6.4.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.4.0"></script>



  

  
    <script id="dsq-count-scr" src="https://yoferzhang.disqus.com/count.js" async></script>
  

  
    <script type="text/javascript">
      var disqus_config = function () {
        this.page.url = 'http://yoferzhang.com/post/20160830ConcurrencyProgrammingGuide/';
        this.page.identifier = 'post/20160830ConcurrencyProgrammingGuide/';
        this.page.title = '【iOS】iOS并发编程对比总结,NSThread,NSOperation,GCD';
        };
      function loadComments () {
        var d = document, s = d.createElement('script');
        s.src = 'https://yoferzhang.disqus.com/embed.js';
        s.setAttribute('data-timestamp', '' + +new Date());
        (d.head || d.body).appendChild(s);
      }
      
        loadComments();
      
    </script>
  












  





  

  

  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  
  

  
  

  
    
      <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      },
      TeX: {equationNumbers: { autoNumber: "AMS" }}
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>
<script type="text/javascript" src="//cdn.jsdelivr.net/npm/mathjax@2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

    
  


  
  
  
  <script src="/lib/needsharebutton/needsharebutton.js"></script>

  <script>
    
      pbOptions = {};
      
          pbOptions.iconStyle = "box";
      
          pbOptions.boxForm = "horizontal";
      
          pbOptions.position = "bottomCenter";
      
          pbOptions.networks = "Weibo,Wechat,Douban,QQZone,Twitter,Facebook";
      
      new needShareButton('#needsharebutton-postbottom', pbOptions);
    
    
  </script>

  

  
  
  
  <script src="/lib/pangu/dist/pangu.min.js?v=3.3"></script>
  <script type="text/javascript">pangu.spacingPage();</script>


  

  

  

  
  <style>
    .copy-btn {
      display: inline-block;
      padding: 6px 12px;
      font-size: 13px;
      font-weight: 700;
      line-height: 20px;
      color: #333;
      white-space: nowrap;
      vertical-align: middle;
      cursor: pointer;
      background-color: #eee;
      background-image: linear-gradient(#fcfcfc, #eee);
      border: 1px solid #d5d5d5;
      border-radius: 3px;
      user-select: none;
      outline: 0;
    }

    .highlight-wrap .copy-btn {
      transition: opacity .3s ease-in-out;
      opacity: 0;
      padding: 2px 6px;
      position: absolute;
      right: 4px;
      top: 8px;
    }

    .highlight-wrap:hover .copy-btn,
    .highlight-wrap .copy-btn:focus {
      opacity: 1
    }

    .highlight-wrap {
      position: relative;
    }
  </style>
  <script>
    $('.highlight').each(function (i, e) {
      var $wrap = $('<div>').addClass('highlight-wrap')
      $(e).after($wrap)
      $wrap.append($('<button>').addClass('copy-btn').append('复制').on('click', function (e) {
        var code = $(this).parent().find('.code').find('.line').map(function (i, e) {
          return $(e).text()
        }).toArray().join('\n')
        var ta = document.createElement('textarea')
        document.body.appendChild(ta)
        ta.style.position = 'absolute'
        ta.style.top = '0px'
        ta.style.left = '0px'
        ta.value = code
        ta.select()
        ta.focus()
        var result = document.execCommand('copy')
        document.body.removeChild(ta)
        
        $(this).blur()
      })).on('mouseleave', function (e) {
        var $b = $(this).find('.copy-btn')
        setTimeout(function () {
          $b.text('复制')
        }, 300)
      }).append(e)
    })
  </script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({"tex2jax":{"inlineMath":[["$","$"],["\\(","\\)"]],"skipTags":["script","noscript","style","textarea","pre","code"],"processEscapes":true},"TeX":{"equationNumbers":{"autoNumber":"AMS"}}});
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->


</body>
</html>
